-- CS_TradeAuto_MinimalWithPetPick.client.lua
-- Auto trade with pet scan/focus, pause at 0/x, resume at full cap, and multi-name auto-accept.
task.wait(40)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Shared = require(ReplicatedStorage:WaitForChild("Shared"))
local ResMutate = require(ReplicatedStorage:WaitForChild("Config"):WaitForChild("ResMutate"))
local Pet = Shared("Pet")

local Remote = ReplicatedStorage:WaitForChild("Remote")
local TradeRE = Remote:WaitForChild("TradeRE")
local CharacterRE = Remote:WaitForChild("CharacterRE")

-- === Safe Remote wrappers ===
local function _sanitizeArg(a)
	local t = typeof(a)
	if t == "function" then
		return nil, "function"
	elseif t == "table" then
		local clean = {}
		for k, v in pairs(a) do
			if typeof(v) ~= "function" then
				clean[k] = v
			end
		end
		return clean
	else
		return a
	end
end

local function safeFire(remote, ...)
	if not remote or typeof(remote) ~= "Instance" or remote.ClassName ~= "RemoteEvent" then
		warn("[AutoTrade] safeFire: invalid remote", remote and typeof(remote), remote and remote.ClassName)
		return false
	end
	local raw = { ... }
	local args = {}
	for i = 1, #raw do
		local a, bad = _sanitizeArg(raw[i])
		if bad then
			warn(string.format("[AutoTrade] safeFire: dropped arg #%d of type %s", i, bad))
		end
		args[#args + 1] = a
	end
	local ok, err = pcall(function()
		remote:FireServer(unpack(args))
	end)
	if not ok then
		warn("[AutoTrade] safeFire failed:", err)
	end
	return ok
end
-- === End Safe Remote wrappers ===

-- === CONFIG ===
local TARGET_PET_NAMES = { "Toothless", "xxx", "zzx" } -- add your list here
local MAX_BARGAINS_PER_TRADE = 2
local DECISION_DELAY = 1.0
local TELEPORT_Y_OFFSET = -1
local PAUSE_WHEN_ZERO = true
local bargainedOnce = false -- remember that we already bargained once
local homedWhileWaiting = false -- NEW: teleport-home-once debounce

-- Helper: force-close trade dialog UI locally
local function _closeTradeUI()
	local Players = game:GetService("Players")
	local LocalPlayer = Players.LocalPlayer
	local pg = LocalPlayer and LocalPlayer:FindFirstChild("PlayerGui")
	if pg then
		for _, gui in ipairs(pg:GetDescendants()) do
			if gui:IsA("ScreenGui") or gui:IsA("SurfaceGui") then
				local root = gui:FindFirstChild("Root")
				if root and root:FindFirstChild("Accept") and root:FindFirstChild("Decline") then
					gui.Enabled = false
				end
			end
		end
	end
	-- If the dialog script exposed a closer, use it too (safer)
	local ok = false
	if shared and type(shared.S_CloseDialogTrade) == "function" then
		ok = pcall(shared.S_CloseDialogTrade)
	end
	if (not ok) and _G and type(_G.S_CloseDialogTrade) == "function" then
		pcall(_G.S_CloseDialogTrade)
	end
end

-- NEW:
local TRADE_RESTART_DELAY = 3 -- small delay before attempting next trade
local REQUEST_TRADE_ON_START = true -- send reqtrade after we move/focus (helps looping)
local AUTO_TELEPORT_HOME_ON_ACCEPT = false -- keep false for unlimited loop
-- Forward declarations to avoid nil when events fire early
local startCycle
local afterTradeTeleportAndContinue

-- build lowercase lookup
local TARGET_SET = {}
for _, n in ipairs(TARGET_PET_NAMES) do
	TARGET_SET[string.lower(n)] = true
end

-- === HELPERS: world paths ===
local function waitIslandName()
	while not LocalPlayer:GetAttribute("AssignedIslandName") do
		task.wait()
	end
	return LocalPlayer:GetAttribute("AssignedIslandName")
end

-- Build the new path dynamically
local auto =
	LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("OverlaySafe"):WaitForChild("Right"):WaitForChild("Candy")

local function getCountLabel()
	local islandName = waitIslandName()
	local art = Workspace:WaitForChild("Art")
	local island = art:WaitForChild(islandName)
	local env = island:WaitForChild("ENV")
	local tz = env:WaitForChild("TradeZone")
	local board = tz:WaitForChild("TradeZoneBoard")
	local c = board:WaitForChild("C")
	local gui = c:WaitForChild("SurfaceGui")
	local num = gui:WaitForChild("Num")
	return num:WaitForChild("Count")
end

local function getTradePart()
	local islandName = LocalPlayer:GetAttribute("AssignedIslandName")
	if not islandName then
		warn("[Teleport] Missing AssignedIslandName.")
		return nil
	end

	local path = Workspace:FindFirstChild("Art")
	if not path then
		return nil
	end

	local island = path:FindFirstChild(islandName)
	if not island then
		return nil
	end

	local env = island:FindFirstChild("ENV")
	if not env then
		return nil
	end

	local tz = env:FindFirstChild("TradeZone")
	if not tz then
		return nil
	end

	local zone = tz:FindFirstChild("Zone")
	if not zone then
		return nil
	end

	local t5 = zone:FindFirstChild("TradeZone5")
	if not t5 then
		return nil
	end

	-- find TradePart inside TradeZone5
	local tradePart = t5:FindFirstChild("TradePart", true)
	if not tradePart or not tradePart:IsA("BasePart") then
		warn("[Teleport] TradePart not found inside TradeZone5.")
		return nil
	end

	return tradePart
end

local function teleportToTradeZone5()
	local tradePart = getTradePart()
	if not tradePart then
		return false
	end

	if Workspace.StreamingEnabled then
		pcall(function()
			Workspace:RequestStreamAroundAsync(tradePart.Position)
		end)
		task.wait(0.1)
	end

	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local root = char:WaitForChild("HumanoidRootPart")

	root.AssemblyLinearVelocity = Vector3.zero
	root.AssemblyAngularVelocity = Vector3.zero

	local targetPos = tradePart.Position + Vector3.new(0, TELEPORT_Y_OFFSET, 0) -- use TELEPORT_Y_OFFSET
	local lookAt = tradePart.Position + tradePart.CFrame.LookVector

	root.CFrame = CFrame.new(targetPos, lookAt)

	print("[Teleport] Teleported to TradePart pivot:", tradePart:GetFullName())
	return true
end

-- Build one pet row (name, muts, produce, gemCost)
local function buildOne(petData)
	if typeof(petData) ~= "table" then
		return nil
	end
	local def = Pet:GetDef(petData.T) or {}
	local name = def.Name or def.DisplayName or petData.Name or tostring(petData.T or "?")
	local muts = (petData.M and petData.M ~= "") and petData.M or "-"

	local produce = Pet:GetPetProduce(petData, 1) or 0
	local baseRate = def.TradeCostRate or 0
	local mutRate = 1
	if petData.M and petData.M ~= "" and ResMutate[petData.M] and ResMutate[petData.M].TradeCostRate then
		mutRate = tonumber(ResMutate[petData.M].TradeCostRate) or 1
	end
	local gemCost = math.floor(baseRate * mutRate)

	return { name = name, muts = muts, produce = produce, gemCost = gemCost }
end

-- Print details for both sides (you + trader), plus totals and bargain info
local function printTradeDetails(payload)
	-- payload might be wrapped in payload.data by your server
	local p = payload
	if p and p.data and (p.data.HoldPet or p.data.TradePet) then
		p = p.data
	end
	if not p then
		return
	end

	local you = buildOne(p.HoldPet)
	local traderList, totalTraderProduce, totalTraderGem = {}, 0, 0

	for _, item in pairs(p.TradePet or {}) do
		local info = buildOne(item)
		if info then
			table.insert(traderList, info)
			totalTraderProduce = totalTraderProduce + (info.produce or 0)
			totalTraderGem = totalTraderGem + (info.gemCost or 0)
		end
	end

	print("=== TRADE DEBUG ===")
	if you then
		print(
			("YOU:     %s | muts: %s | produce: %d | gemCost: %d"):format(you.name, you.muts, you.produce, you.gemCost)
		)
	else
		print("YOU:     <none>")
	end

	if #traderList == 0 then
		print("TRADER:  <none>")
	else
		for i, info in ipairs(traderList) do
			print(
				("TRADER[%d]: %s | muts: %s | produce: %d | gemCost: %d"):format(
					i,
					info.name,
					info.muts,
					info.produce,
					info.gemCost
				)
			)
		end
	end

	-- Totals
	local youProduce = (you and you.produce) or 0
	local youGem = (you and you.gemCost) or 0
	print(
		("TOTALS  | You: produce=%d, gemCost=%d  | Trader: produce=%d, gemCost=%d"):format(
			youProduce,
			youGem,
			totalTraderProduce,
			totalTraderGem
		)
	)

	-- Optional: show bargain info if present
	if p.BargainRate ~= nil then
		print(("BargainRate: %d%%"):format(math.floor((p.BargainRate or 0) * 100)))
	end
	if p.BargainTime ~= nil then
		print(("BargainTime: %s"):format(tostring(p.BargainTime)))
	end
	print("=== END TRADE DEBUG ===")
end

-- === PET PICK (lowest produce, not D/LK) ===
local function chooseLowestProduceUID()
	local pg = LocalPlayer:FindFirstChild("PlayerGui")
	if not pg then
		return nil
	end
	local data = pg:FindFirstChild("Data")
	if not data then
		return nil
	end
	local pets = data:FindFirstChild("Pets")
	if not pets then
		return nil
	end

	local list = {}
	for _, petNode in ipairs(pets:GetChildren()) do
		local hasD = petNode:GetAttribute("D")
		local hasLK = petNode:GetAttribute("LK")
		if not hasD and not hasLK then
			local t = petNode:GetAttribute("T")
			local m = petNode:GetAttribute("M")
			if t then
				local produce = Pet:GetPetProduce({ T = t, M = m }, 1) or 0
				table.insert(list, { uid = petNode.Name, produce = produce })
			end
		end
	end
	table.sort(list, function(a, b)
		return a.produce < b.produce
	end)
	return list[1] and list[1].uid or nil
end

-- Keep your existing CharacterRE reference:
-- local CharacterRE = game:GetService("ReplicatedStorage"):WaitForChild("Remote"):WaitForChild("CharacterRE")

local function focusUID(uid)
	-- sanity checks
	if not CharacterRE or CharacterRE.ClassName ~= "RemoteEvent" then
		warn("[AutoTrade] CharacterRE missing or not a RemoteEvent:", CharacterRE and CharacterRE.ClassName)
		return false
	end
	if uid == nil then
		warn("[AutoTrade] focusUID got nil uid")
		return false
	end
	if typeof(uid) == "function" then
		warn("[AutoTrade] focusUID got a FUNCTION, call chooseLowestProduceUID() with parentheses")
		return false
	end

	uid = tostring(uid)

	local args = { "Focus", uid }
	print("[AutoTrade] Focus ->", uid)
	safeFire(CharacterRE, "Focus", uid)
	return true
end

local function clearHand()
	-- sanity checks
	if not CharacterRE or CharacterRE.ClassName ~= "RemoteEvent" then
		warn("[AutoTrade] CharacterRE missing or not a RemoteEvent:", CharacterRE and CharacterRE.ClassName)
		return false
	end

	local args = { "Focus" }
	print("[AutoTrade] Focus ->")
	safeFire(CharacterRE, "Focus", uid)
	return true
end

-- === TRADE DECODE/DECISION ===
local function findTradeCore(root)
	if typeof(root) ~= "table" then
		return nil
	end
	for k, v in pairs(root) do
		if k == "HoldPet" or k == "holdpet" or k == "You" then
			return { hold = v, trader = root.TradePet or root.tradepet or root.TraderPet or root.Trade }
		end
		if typeof(v) == "table" then
			local r = findTradeCore(v)
			if r then
				return r
			end
		end
	end
	return nil
end

local function getProduce(p)
	if typeof(p) ~= "table" then
		return 0
	end
	return Pet:GetPetProduce(p, 1) or 0
end

local function traderHasAnyTargetName(trader)
	if typeof(trader) ~= "table" then
		return false
	end
	local function matchOne(p)
		if typeof(p) ~= "table" then
			return false
		end
		local def = Pet:GetDef(p.T) or {}
		local name = def.Name or def.DisplayName or p.Name or tostring(p.T or "")
		return TARGET_SET[string.lower(name or "")]
	end
	for _, v in pairs(trader) do
		if typeof(v) == "table" and matchOne(v) then
			return true
		end
	end
	return false
end

-- === STATES ===
local paused = false
local currentlyTrading = false
local acceptedOrDeclined = false

-- Returns x, y as numbers (or nil, nil if not parsable)
local function parseXY(text)
	local a, b = string.match(text or "", "^(%d+)%s*/%s*(%d+)$")
	if not a or not b then
		return nil, nil
	end
	return tonumber(a), tonumber(b)
end

-- 0..1 progress (or nil if not parsable)
local function progress01(text)
	local x, y = parseXY(text)
	if not x or not y or y == 0 then
		return nil
	end
	return x / y
end

local function isCapReached(text)
	local x, y = parseXY(text)
	if not x or not y then
		return false, nil, nil
	end

	if PAUSE_WHEN_ZERO and x == 0 then
		paused = true
		print(string.format("[AutoTrade] Paused (0/%d)", y))
		return false, x, y
	end

	if x >= y then
		paused = false
		return true, x, y -- cap/full
	end

	return false, x, y
end

local function decideAndAct(payload)
	while payload == "" do
		task.wait()
	end
	if acceptedOrDeclined then
		return
	end
	local core = findTradeCore(payload)
	if not core then
		return
	end

	task.wait(DECISION_DELAY)

	local myVal = getProduce(core.hold)
	local traderVal = 0
	for _, v in pairs(core.trader) do
		traderVal = traderVal + getProduce(v)
	end

	print(("[AutoTrade] First decision: My=%d | Trader=%d"):format(myVal, traderVal))

	-- Rule 1: trader offers target pet -> accept
	if traderHasAnyTargetName(core.trader) then
		print("[AutoTrade] Target name matched → ACCEPT")
		safeFire(TradeRE, { event = "accept" })
		_closeTradeUI()
		task.wait(0.2)
		acceptedOrDeclined = true
		currentlyTrading = false
		afterTradeTeleportAndContinue()
		return
	end

	-- Rule 2: my value < trader value -> accept immediately
	if myVal < traderVal then
		print("[AutoTrade] MyValue < TraderValue → ACCEPT immediately")
		safeFire(TradeRE, { event = "accept" })
		_closeTradeUI()
		task.wait(0.2)
		acceptedOrDeclined = true
		currentlyTrading = false
		afterTradeTeleportAndContinue()
		return
	end

	-- Rule 3: my value > trader value -> bargain once
	if myVal > traderVal and not bargainedOnce then
		task.wait(0.2)
		print("[AutoTrade] MyValue > TraderValue → DECLINE")
		bargainedOnce = true
		acceptedOrDeclined = true
		currentlyTrading = false
		afterTradeTeleportAndContinue()
		return
	end
end

-- Use the existing getCountLabel() + isCapReached()
afterTradeTeleportAndContinue = function()
	task.spawn(function()
		print("[AutoTrade] Teleporting Home after trade...")
		safeFire(CharacterRE, "Teleport", "Home")
		task.wait(2)

		local uid = chooseLowestProduceUID()
		if uid then
			focusUID(uid)
			task.wait(0.2)
		else
			warn("[AutoTrade] No valid pet UID found after teleport.")
		end

		if not paused then
			teleportToTradeZone5()
			startCycle()
		else
			print("[AutoTrade] Paused (0/x); waiting to refill.")
		end
	end)
end

TradeRE.OnClientEvent:Connect(function(payload)
	if not currentlyTrading or paused then
		return
	end
	if typeof(payload) ~= "table" then
		return
	end

	if payload.event == "reqtrade" then
		acceptedOrDeclined = false
		bargainedOnce = false
		decideAndAct(payload)
		printTradeDetails(payload)
	elseif payload.event == "bargainresult" then
		-- After 1x bargain, decide: if trader total < my value -> DECLINE, else ACCEPT
		if not payload.result then
			-- bargain failed: treat it as still worse → decline
			local compare = payload.data or payload
			local core = findTradeCore(compare)
			if not core then
				return
			end
			local myVal = getProduce(core.hold)
			local traderVal = 0
			for _, v in pairs(core.trader) do
				traderVal = traderVal + getProduce(v)
			end
			print(("[AutoTrade] Bargain failed -> My=%d | Trader=%d → DECLINE"):format(myVal, traderVal))
			acceptedOrDeclined = true
			currentlyTrading = false
			afterTradeTeleportAndContinue() -- NEW: queue the next trade
			return
		end

		-- bargain succeeded: evaluate updated offer
		local compare = payload.data or payload
		local core = findTradeCore(compare)
		if not core then
			warn("[AutoTrade] No trade core in bargainresult payload.")
			return
		end

		local myVal = getProduce(core.hold)
		local traderVal = 0
		for _, v in pairs(core.trader) do
			traderVal = traderVal + getProduce(v)
		end

		print(("[AutoTrade] Post-bargain values -> My=%d | Trader=%d"):format(myVal, traderVal))
		printTradeDetails(payload)
		task.wait(0.3)
		if traderVal < myVal then
			print("[AutoTrade] Trader still worse after 1x bargain → DECLINE")
		elseif myVal < traderVal then
			print("[AutoTrade] Trader better after 1x bargain → ACCEPT")
			safeFire(TradeRE, { event = "accept" })
			_closeTradeUI()
		else
			print("[AutoTrade] Equal values after bargain → DECLINE")
			-- safeFire(TradeRE, { event = "accept" })
		end
		acceptedOrDeclined = true
		currentlyTrading = false
		afterTradeTeleportAndContinue()
	end
end)

-- === CYCLE ===
startCycle = function()
	if paused then
		print("[AutoTrade] Waiting for full cap…")
		return
	end
	local uid = chooseLowestProduceUID()
	if uid then
		focusUID(uid)
		task.wait(0.1)
	end
	teleportToTradeZone5()
	currentlyTrading = true
end

startCycle()
task.spawn(function()
	local label = getCountLabel()
	label:GetPropertyChangedSignal("Text"):Connect(function()
		local full = isCapReached(label.Text)
		if full then
			-- Full (10/10): reset debounce and go
			if homedWhileWaiting then
				print("[AutoTrade] Refilled to full → resuming.")
			end
			homedWhileWaiting = false
			startCycle()
		else
			-- Not full: Home once, then wait until full
			if not homedWhileWaiting then
				homedWhileWaiting = true
				print(
					"[AutoTrade] Not full ("
						.. tostring(label.Text)
						.. ") → teleporting Home while waiting for 10/10."
				)
				safeFire(CharacterRE, "Teleport", "Home")
			end
		end
	end)

	-- Initial kick
	local full = isCapReached(label.Text)
	if full then
		homedWhileWaiting = false
		startCycle()
	else
		if not homedWhileWaiting then
			homedWhileWaiting = true
			print(
				"[AutoTrade] Startup: not full ("
					.. tostring(label.Text)
					.. ") → teleporting Home while waiting for 10/10."
			)
			safeFire(CharacterRE, "Teleport", "Home")
		end
	end
end)
