--======================================================
-- BRVS: Rayfield-powered Tools
--======================================================

--// Services (prefixed)
local BRVS_Players = game:GetService("Players")
local BRVS_ReplicatedStorage = game:GetService("ReplicatedStorage")
local BRVS_Lighting = game:GetService("Lighting")
local BRVS_Workspace = game:GetService("Workspace")

local BRVS_Player = BRVS_Players.LocalPlayer
local BRVS_UserId = BRVS_Player.UserId

local BRVS_Candy =
	BRVS_Player:WaitForChild("PlayerGui"):WaitForChild("OverlaySafe"):WaitForChild("Right"):WaitForChild("Candy")

--// Fixed lists (prefixed)
local BRVS_EGG_NAMES = {
	"MetroGiraffeEgg",
	"GodzillaEgg",
	"GeneralKongEgg",
	"DinoEgg",
	"CelesteEgg",
	"SnowbunnyEgg",
	"PrismaticEgg",
	"HyperEgg",
	"DarkGoatyEgg",
	"VoidEgg",
	"BowserEgg",
	"DemonEgg",
	"RhinoRockEgg",
	"CornEgg",
	"BoneDragonEgg",
	"UltraEgg",
	"EpicEgg",
	"FlyEgg",
	"SaberCubEgg",
	"UnicornEgg",
	"AncientEgg",
	"SeaDragonEgg",
	"UnicornProEgg",
	"RareEgg",
	"SuperRareEgg",
	"PegasusEgg",
	"LegendEgg",
	"BasicEgg",
}
local BRVS_MUTATIONS = { "Halloween", "Snow", "Dino", "Diamond", "Electirc", "Fire", "Golden", "None" }

-- Rayfield display lists with explicit "Any"
local BRVS_EGG_OPTIONS = (function()
	local t = { "Any" }
	for _, v in ipairs(BRVS_EGG_NAMES) do
		table.insert(t, v)
	end
	return t
end)()
local BRVS_MUTATION_OPTIONS = (function()
	local t = { "Any" }
	for _, v in ipairs(BRVS_MUTATIONS) do
		table.insert(t, v)
	end
	return t
end)()

-- Food options (multi-select)
local BRVS_FOOD_OPTIONS = {
	"FrankenKiwi",
	"VoltGinkgo",
	"CandyCorn",
	"Pumpkin",
	"Durian",
	"DeepseaPearlFruit",
	"Pear",
	"Pineapple",
	"DragonFruit",
	"GoldMango",
	"BloodstoneCycad",
	"ColossalPinecone",
	"Banana",
	"Grape",
	"Strawberry",
	"Blueberry",
	"Watermelon",
	"Apple",
	"Orange",
	"Corn",
}

--// World paths
local BRVS_ART_FOLDER = workspace:WaitForChild("Art")
local BRVS_EGGS_FOLDER = BRVS_ReplicatedStorage:WaitForChild("Eggs")

--// Remotes/config
local BRVS_token = game:GetService("ReplicatedStorage").Time
local BRVS_BUYEGG_REMOTE_PATH = { "Remote", "CharacterRE" } -- ReplicatedStorage.Remote.CharacterRE
local BRVS_BUYEGG_ACTION = "BuyEgg"
local BRVS_AUTO_BUY_COOLDOWN = 2 -- seconds per-egg debounce
local BRVS_FOOD_REMOTE_PATH = { "Remote", "FoodStoreRE" } -- ReplicatedStorage.Remote.FoodStoreRE

--========================================================
-- Utils (prefixed)
local function BRVS_GetMyIslandName()
	for i = 1, 6 do
		local island = BRVS_ART_FOLDER:FindFirstChild("Island_" .. i)
		if island and island:GetAttribute("OccupyingPlayerId") == BRVS_UserId then
			return island.Name
		end
	end
	return nil
end

local function BRVS_ContainsOrAny(list, value)
	if not list or #list == 0 then
		return true
	end
	for _, v in ipairs(list) do
		if v == "Any" then
			return true
		end
		if v == value then
			return true
		end
	end
	return false
end

-- Safe remote getter (non-blocking)
local function BRVS_GetRemote(pathArray)
	local node = BRVS_ReplicatedStorage
	for _, name in ipairs(pathArray) do
		node = node and node:FindFirstChild(name)
		if not node then
			return nil
		end
	end
	return node
end

-- CharacterRE getter (shared by features)
local function BRVS_GetCharacterRE()
	local re = BRVS_GetRemote({ "Remote", "CharacterRE" })
	if re and re:IsA("RemoteEvent") then
		return re
	end
	return nil
end

--========================================================
-- State (prefixed)
local BRVS_IslandName = BRVS_GetMyIslandName()
local BRVS_IslandFolder = BRVS_IslandName
		and (BRVS_EGGS_FOLDER:FindFirstChild(BRVS_IslandName) or BRVS_EGGS_FOLDER:WaitForChild(BRVS_IslandName, 10))
	or nil
local BRVS_Conns, BRVS_PerEggConns = {}, {}
local function BRVS_ClearConns(t)
	for _, c in ipairs(t) do
		pcall(function()
			c:Disconnect()
		end)
	end
	table.clear(t)
end
local function BRVS_ClearPerEggConns()
	for _, b in pairs(BRVS_PerEggConns) do
		for _, c in ipairs(b) do
			pcall(function()
				c:Disconnect()
			end)
		end
	end
	BRVS_PerEggConns = {}
end

-- User selections (from Rayfield)
local BRVS_SelEggNames = {} -- {} or includes "Any"
local BRVS_SelMutations = {} -- {} or includes "Any" / "None"

-- Toggles / misc
local BRVS_AutoBuyEnabled = false
local BRVS_LastFireAt = {} -- [Instance]=time

-- Food auto-buy state
local BRVS_SelectedFood = {} -- multi-select strings
local BRVS_FoodBuyEnabled = false
local BRVS_FoodBuyInterval = 0.2 -- seconds
local BRVS_FoodBuyThread

-- Anti AFK (jump)
local BRVS_AntiAfkConn, BRVS_AntiAfkThread

-- Ultra Low (merged No Lag + Low Graphics)
local BRVS_SavedStates = {} -- [Instance] = original Enabled (emitters/lights)
local BRVS_Terrain = workspace:FindFirstChildOfClass("Terrain")

-- Auto Collect
local BRVS_PetCollectEnabled = false
local BRVS_PetCollectInterval = 3
local BRVS_PetCollectThread

--========================================================
-- Anti-AFK helpers
local function BRVS_GetHumanoid()
	local char = BRVS_Players.LocalPlayer.Character or BRVS_Players.LocalPlayer.CharacterAdded:Wait()
	return char:FindFirstChildOfClass("Humanoid")
end
local function BRVS_PerformJump(times)
	times = times or 1
	local hum = BRVS_GetHumanoid()
	if not hum then
		return
	end
	for _ = 1, times do
		hum.Jump = true
		hum:ChangeState(Enum.HumanoidStateType.Jumping)
		task.wait(0.2)
	end
end

--========================================================
-- Low graphics helpers (kept same behavior)
local BRVS_LG_CONFIG = { DisableTextures = true, HideSurfaceAppearance = false, DisableNonPlayerAnimations = true }
local function BRVS_g(inst, prop)
	local ok, v = pcall(function()
		return inst[prop]
	end)
	return ok and v or nil
end
local function BRVS_s(inst, prop, val)
	pcall(function()
		inst[prop] = val
	end)
end

local BRVS_lightingProps = {
	"GlobalShadows",
	"EnvironmentSpecularScale",
	"EnvironmentDiffuseScale",
	"Brightness",
	"Ambient",
	"OutdoorAmbient",
	"FogStart",
	"FogEnd",
	"FogColor",
	"ClockTime",
	"ShadowSoftness",
	"Technology",
}
local BRVS_terrainProps =
	{ "Decoration", "WaterWaveSize", "WaterWaveSpeed", "WaterReflectance", "WaterTransparency", "WaterColor" }

local BRVS_LG_original =
	{ lighting = {}, terrain = {}, postFX = {}, atmo = nil, decals = {}, textures = {}, surfaceA = {} }
for _, p in ipairs(BRVS_lightingProps) do
	BRVS_LG_original.lighting[p] = BRVS_g(BRVS_Lighting, p)
end
for _, fx in ipairs(BRVS_Lighting:GetDescendants()) do
	if fx:IsA("PostEffect") then
		BRVS_LG_original.postFX[fx] = fx.Enabled
	end
end
do
	local A = BRVS_Lighting:FindFirstChildOfClass("Atmosphere")
	if A then
		BRVS_LG_original.atmo = {
			obj = A,
			props = {
				Density = BRVS_g(A, "Density"),
				Offset = BRVS_g(A, "Offset"),
				Color = BRVS_g(A, "Color"),
				Decay = BRVS_g(A, "Decay"),
				Glare = BRVS_g(A, "Glare"),
				Haze = BRVS_g(A, "Haze"),
				MieScatteringScale = BRVS_g(A, "MieScatteringScale"),
			},
		}
	end
end
if BRVS_Terrain then
	for _, p in ipairs(BRVS_terrainProps) do
		BRVS_LG_original.terrain[p] = BRVS_g(BRVS_Terrain, p)
	end
end
local function BRVS_LG_snapshotVisuals()
	if BRVS_LG_CONFIG.DisableTextures then
		for _, obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("Decal") then
				if BRVS_LG_original.decals[obj] == nil then
					BRVS_LG_original.decals[obj] = BRVS_g(obj, "Transparency")
				end
			elseif obj:IsA("Texture") then
				if BRVS_LG_original.textures[obj] == nil then
					BRVS_LG_original.textures[obj] = BRVS_g(obj, "Transparency")
				end
			end
		end
	end
	if BRVS_LG_CONFIG.HideSurfaceAppearance then
		for _, obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("SurfaceAppearance") and BRVS_LG_original.surfaceA[obj] == nil then
				BRVS_LG_original.surfaceA[obj] = {
					ColorMap = BRVS_g(obj, "ColorMap"),
					MetalnessMap = BRVS_g(obj, "MetalnessMap"),
					NormalMap = BRVS_g(obj, "NormalMap"),
					RoughnessMap = BRVS_g(obj, "RoughnessMap"),
				}
			end
		end
	end
end
BRVS_LG_snapshotVisuals()

local BRVS_LG_animBlockConns, BRVS_LG_animAddedConn = {}, nil
local function BRVS_LG_isLocalCharacterHumanoid(h)
	local c = BRVS_Players.LocalPlayer.Character
	return c and h and h:IsDescendantOf(c)
end
local function BRVS_LG_stopAnimator(anim)
	for _, t in ipairs(anim:GetPlayingAnimationTracks()) do
		pcall(function()
			t:Stop(0)
		end)
	end
	if not BRVS_LG_animBlockConns[anim] then
		BRVS_LG_animBlockConns[anim] = anim.AnimationPlayed:Connect(function(track)
			pcall(function()
				track:Stop(0)
			end)
		end)
	end
end
local function BRVS_LG_applyAnimationBlock()
	for _, o in ipairs(workspace:GetDescendants()) do
		if o:IsA("Humanoid") then
			if not BRVS_LG_isLocalCharacterHumanoid(o) then
				local a = o:FindFirstChildOfClass("Animator")
				if a then
					BRVS_LG_stopAnimator(a)
				end
			end
		elseif o:IsA("AnimationController") then
			local a = o:FindFirstChildOfClass("Animator")
			if a then
				BRVS_LG_stopAnimator(a)
			end
		end
	end
	if not BRVS_LG_animAddedConn then
		BRVS_LG_animAddedConn = workspace.DescendantAdded:Connect(function(o)
			if o:IsA("Animator") and BRVS_LG_CONFIG.DisableNonPlayerAnimations then
				local h = o.Parent and o.Parent:FindFirstChildOfClass("Humanoid")
				if h and BRVS_LG_isLocalCharacterHumanoid(h) then
					return
				end
				BRVS_LG_stopAnimator(o)
			end
		end)
	end
end
local function BRVS_LG_clearAnimationBlock()
	for a, c in pairs(BRVS_LG_animBlockConns) do
		if c then
			c:Disconnect()
		end
		BRVS_LG_animBlockConns[a] = nil
	end
	if BRVS_LG_animAddedConn then
		BRVS_LG_animAddedConn:Disconnect()
		BRVS_LG_animAddedConn = nil
	end
end
local function BRVS_ApplyLowGraphics()
	BRVS_s(BRVS_Lighting, "GlobalShadows", false)
	BRVS_s(BRVS_Lighting, "EnvironmentSpecularScale", 0)
	BRVS_s(BRVS_Lighting, "EnvironmentDiffuseScale", 0)
	BRVS_s(BRVS_Lighting, "ShadowSoftness", 0)
	for fx in pairs(BRVS_LG_original.postFX) do
		if fx and fx.Parent then
			BRVS_s(fx, "Enabled", false)
		end
	end
	if BRVS_LG_original.atmo and BRVS_LG_original.atmo.obj then
		local A = BRVS_LG_original.atmo.obj
		BRVS_s(A, "Density", 0)
		BRVS_s(A, "Glare", 0)
		BRVS_s(A, "Haze", 0)
		BRVS_s(A, "MieScatteringScale", 0)
	end
	if BRVS_Terrain then
		BRVS_s(BRVS_Terrain, "Decoration", false)
		BRVS_s(BRVS_Terrain, "WaterWaveSize", 0)
		BRVS_s(BRVS_Terrain, "WaterWaveSpeed", 0)
		BRVS_s(BRVS_Terrain, "WaterReflectance", 0)
		BRVS_s(BRVS_Terrain, "WaterTransparency", 0)
		BRVS_s(BRVS_Terrain, "WaterColor", Color3.fromRGB(85, 170, 255))
	end
	if BRVS_LG_CONFIG.DisableTextures then
		for o in pairs(BRVS_LG_original.decals) do
			if o and o.Parent then
				BRVS_s(o, "Transparency", 1)
			end
		end
		for o in pairs(BRVS_LG_original.textures) do
			if o and o.Parent then
				BRVS_s(o, "Transparency", 1)
			end
		end
	end
	if BRVS_LG_CONFIG.HideSurfaceAppearance then
		for o in pairs(BRVS_LG_original.surfaceA) do
			if o and o.Parent then
				BRVS_s(o, "ColorMap", "")
				BRVS_s(o, "MetalnessMap", "")
				BRVS_s(o, "NormalMap", "")
				BRVS_s(o, "RoughnessMap", "")
			end
		end
	end
	if BRVS_LG_CONFIG.DisableNonPlayerAnimations then
		BRVS_LG_applyAnimationBlock()
	end
end
local function BRVS_RestoreLowGraphics()
	for p, v in pairs(BRVS_LG_original.lighting) do
		BRVS_s(BRVS_Lighting, p, v)
	end
	for fx, was in pairs(BRVS_LG_original.postFX) do
		if fx and fx.Parent then
			BRVS_s(fx, "Enabled", was)
		end
	end
	if BRVS_LG_original.atmo and BRVS_LG_original.atmo.obj and BRVS_LG_original.atmo.props then
		for p, v in pairs(BRVS_LG_original.atmo.props) do
			BRVS_s(BRVS_LG_original.atmo.obj, p, v)
		end
	end
	if BRVS_Terrain then
		for p, v in pairs(BRVS_LG_original.terrain) do
			BRVS_s(BRVS_Terrain, p, v)
		end
	end
	if BRVS_LG_CONFIG.DisableTextures then
		for o, prev in pairs(BRVS_LG_original.decals) do
			if o and o.Parent then
				BRVS_s(o, "Transparency", prev)
			end
		end
		for o, prev in pairs(BRVS_LG_original.textures) do
			if o and o.Parent then
				BRVS_s(o, "Transparency", prev)
			end
		end
	end
	if BRVS_LG_CONFIG.HideSurfaceAppearance then
		for o, props in pairs(BRVS_LG_original.surfaceA) do
			if o and o.Parent then
				for k, v in pairs(props) do
					BRVS_s(o, k, v)
				end
			end
		end
	end
	BRVS_LG_clearAnimationBlock()
end
local function BRVS_ApplyUltraLow()
	for _, inst in ipairs(workspace:GetDescendants()) do
		if
			inst:IsA("ParticleEmitter")
			or inst:IsA("Trail")
			or inst:IsA("Beam")
			or inst:IsA("Highlight")
			or inst:IsA("PointLight")
			or inst:IsA("SpotLight")
			or inst:IsA("SurfaceLight")
		then
			if BRVS_SavedStates[inst] == nil then
				BRVS_SavedStates[inst] = inst.Enabled
			end
			inst.Enabled = false
		end
	end
	BRVS_Lighting.GlobalShadows = false
	BRVS_ApplyLowGraphics()
end
local function BRVS_RestoreUltraLow()
	for inst, was in pairs(BRVS_SavedStates) do
		if inst and inst.Parent then
			if
				inst:IsA("ParticleEmitter")
				or inst:IsA("Trail")
				or inst:IsA("Beam")
				or inst:IsA("Highlight")
				or inst:IsA("PointLight")
				or inst:IsA("SpotLight")
				or inst:IsA("SurfaceLight")
			then
				inst.Enabled = (was == true)
			end
		end
	end
	table.clear(BRVS_SavedStates)
	BRVS_Lighting.GlobalShadows = true
	BRVS_RestoreLowGraphics()
end

--========================================================
-- Core logic (eggs) (prefixed)
local function BRVS_CurrentSelectionsMatch(egg)
	local nameVal = egg:GetAttribute("T") or "(no value)"
	local rawM = egg:GetAttribute("M")
	local mutVal = rawM or "(no value)"

	local nameOk = BRVS_ContainsOrAny(BRVS_SelEggNames, nameVal)
	local mutOk
	if not BRVS_SelMutations or #BRVS_SelMutations == 0 then
		mutOk = true
	else
		mutOk = false
		for _, opt in ipairs(BRVS_SelMutations) do
			if opt == "Any" then
				mutOk = true
				break
			end
			if opt == mutVal then
				mutOk = true
				break
			end
			if opt == "None" and (rawM == nil or rawM == "") then
				mutOk = true
				break
			end
		end
	end
	return nameOk and mutOk
end

local function BRVS_norm(v)
	if v == nil then
		return "none"
	end
	if typeof(v) ~= "string" then
		v = tostring(v)
	end
	v = v:lower():gsub("%s+", ""):gsub("[_%-%s]", "")
	if v == "" or v == "(novalue)" then
		v = "none"
	end
	return v
end
local function BRVS_matchesFilter(value, filter)
	if filter == nil then
		return true
	end
	if type(filter) == "table" then
		for _, f in ipairs(filter) do
			if BRVS_matchesFilter(value, f) then
				return true
			end
		end
		return false
	end
	if type(filter) == "string" and BRVS_norm(filter) == "any" then
		return true
	end
	return BRVS_norm(value) == BRVS_norm(filter)
end
local function BRVS_PassesFinalSelection(egg, nameFilter, mutFilter)
	if not egg then
		return false
	end
	local eggName = egg:GetAttribute("T") or egg.Name or ""
	local mutAttr = egg:GetAttribute("M")
	if mutAttr == nil or mutAttr == "" then
		mutAttr = "None"
	end
	return BRVS_matchesFilter(eggName, nameFilter) and BRVS_matchesFilter(mutAttr, mutFilter)
end

local function BRVS_AttemptAutoBuy(egg)
	if not BRVS_AutoBuyEnabled then
		return
	end
	if not egg or not egg.Parent or egg.Parent ~= BRVS_IslandFolder then
		return
	end
	if not BRVS_CurrentSelectionsMatch(egg) then
		return
	end
	if not BRVS_PassesFinalSelection(egg, BRVS_SelEggNames, BRVS_SelMutations) then
		return
	end

	local now = os.clock()
	if BRVS_LastFireAt[egg] and (now - BRVS_LastFireAt[egg] < BRVS_AUTO_BUY_COOLDOWN) then
		return
	end
	BRVS_LastFireAt[egg] = now

	local args = { BRVS_BUYEGG_ACTION, egg.Name }
	local remote = BRVS_ReplicatedStorage:WaitForChild(BRVS_BUYEGG_REMOTE_PATH[1])
		:WaitForChild(BRVS_BUYEGG_REMOTE_PATH[2])
	if remote and remote:IsA("RemoteEvent") then
		remote:FireServer(table.unpack(args))
	else
		warn("BRVS AutoBuy: RemoteEvent missing at ReplicatedStorage." .. table.concat(BRVS_BUYEGG_REMOTE_PATH, "."))
	end
end

local function BRVS_PrintMatches()
	if not BRVS_IslandFolder then
		return
	end
	for _, e in ipairs(BRVS_IslandFolder:GetChildren()) do
		if BRVS_CurrentSelectionsMatch(e) then
		end
	end
end

local function BRVS_RescanAutoBuy()
	if not (BRVS_AutoBuyEnabled and BRVS_IslandFolder) then
		return
	end
	for _, egg in ipairs(BRVS_IslandFolder:GetChildren()) do
		BRVS_AttemptAutoBuy(egg)
		task.wait()
	end
end

local function BRVS_BindIsland(newName)
	BRVS_ClearConns(BRVS_Conns)
	BRVS_ClearPerEggConns()
	BRVS_IslandName = newName
	BRVS_IslandFolder = BRVS_IslandName
			and (BRVS_EGGS_FOLDER:FindFirstChild(BRVS_IslandName) or BRVS_EGGS_FOLDER:WaitForChild(BRVS_IslandName, 10))
		or nil
	if not BRVS_IslandFolder then
		return
	end

	for _, egg in ipairs(BRVS_IslandFolder:GetChildren()) do
		local c1 = egg:GetAttributeChangedSignal("T"):Connect(function()
			BRVS_PrintMatches()
			BRVS_AttemptAutoBuy(egg)
		end)
		local c2 = egg:GetAttributeChangedSignal("M"):Connect(function()
			BRVS_PrintMatches()
			BRVS_AttemptAutoBuy(egg)
		end)
		BRVS_PerEggConns[egg] = { c1, c2 }
		BRVS_AttemptAutoBuy(egg)
	end

	table.insert(
		BRVS_Conns,
		BRVS_IslandFolder.ChildAdded:Connect(function(child)
			local c1 = child:GetAttributeChangedSignal("T"):Connect(function()
				BRVS_PrintMatches()
				BRVS_AttemptAutoBuy(child)
			end)
			local c2 = child:GetAttributeChangedSignal("M"):Connect(function()
				BRVS_PrintMatches()
				BRVS_AttemptAutoBuy(child)
			end)
			BRVS_PerEggConns[child] = { c1, c2 }
			BRVS_PrintMatches()
			BRVS_AttemptAutoBuy(child)
		end)
	)

	table.insert(
		BRVS_Conns,
		BRVS_IslandFolder.ChildRemoved:Connect(function(child)
			local b = BRVS_PerEggConns[child]
			if b then
				for _, c in ipairs(b) do
					pcall(function()
						c:Disconnect()
					end)
				end
			end
			BRVS_PerEggConns[child] = nil
			BRVS_PrintMatches()
		end)
	)
end

--========================================================
-- LIVE FOOD STOCK (PlayerGui.Data.FoodStore.LST)
local BRVS_FoodStock = {} -- { [FoodName] = number }
local BRVS_FoodStockConns = {}
local BRVS_LST = nil

local function BRVS_DisconnectStock()
	for _, c in ipairs(BRVS_FoodStockConns) do
		pcall(function()
			c:Disconnect()
		end)
	end
	table.clear(BRVS_FoodStockConns)
end
local function BRVS_SnapshotAttrs(lst)
	table.clear(BRVS_FoodStock)
	for k, v in pairs(lst:GetAttributes()) do
		BRVS_FoodStock[k] = tonumber(v) or 0
	end
	for _, child in ipairs(lst:GetChildren()) do
		if child:IsA("IntValue") or child:IsA("NumberValue") then
			BRVS_FoodStock[child.Name] = tonumber(child.Value) or 0
		end
	end
end
local function BRVS_BindFoodStock()
	BRVS_DisconnectStock()
	local pg = BRVS_Player:WaitForChild("PlayerGui")
	local data = pg:WaitForChild("Data")
	local fs = data:WaitForChild("FoodStore")
	local lst = fs:WaitForChild("LST")
	BRVS_LST = lst

	BRVS_SnapshotAttrs(lst)
	table.insert(
		BRVS_FoodStockConns,
		lst.AttributeChanged:Connect(function(attr)
			local val = lst:GetAttribute(attr)
			BRVS_FoodStock[attr] = tonumber(val) or 0
		end)
	)
	for _, child in ipairs(lst:GetChildren()) do
		if child:IsA("IntValue") or child:IsA("NumberValue") then
			table.insert(
				BRVS_FoodStockConns,
				child:GetPropertyChangedSignal("Value"):Connect(function()
					BRVS_FoodStock[child.Name] = tonumber(child.Value) or 0
				end)
			)
		end
	end
	table.insert(
		BRVS_FoodStockConns,
		lst.ChildAdded:Connect(function(child)
			if child:IsA("IntValue") or child:IsA("NumberValue") then
				BRVS_FoodStock[child.Name] = tonumber(child.Value) or 0
				table.insert(
					BRVS_FoodStockConns,
					child:GetPropertyChangedSignal("Value"):Connect(function()
						BRVS_FoodStock[child.Name] = tonumber(child.Value) or 0
					end)
				)
			end
		end)
	)
	return BRVS_LST
end
local function BRVS_HasFoodStock(name)
	return (BRVS_FoodStock[name] or 0) > 0
end

--========================================================
local BRVS_Theme = {
	TextColor = Color3.fromRGB(255, 180, 100), -- warm orange text
	PlaceholderColor = Color3.fromRGB(180, 130, 90),

	Background = Color3.fromRGB(15, 10, 20), -- deep violet-black
	Topbar = Color3.fromRGB(25, 15, 35),
	Shadow = Color3.fromRGB(8, 5, 12),

	NotificationBackground = Color3.fromRGB(20, 15, 25),
	NotificationActionsBackground = Color3.fromRGB(255, 145, 60),

	TabBackground = Color3.fromRGB(50, 30, 60),
	TabStroke = Color3.fromRGB(80, 40, 90),
	TabBackgroundSelected = Color3.fromRGB(255, 120, 50),
	TabTextColor = Color3.fromRGB(230, 180, 255),
	SelectedTabTextColor = Color3.fromRGB(20, 10, 10),

	ElementBackground = Color3.fromRGB(25, 15, 35),
	ElementBackgroundHover = Color3.fromRGB(35, 20, 45),
	SecondaryElementBackground = Color3.fromRGB(18, 12, 25),
	ElementStroke = Color3.fromRGB(70, 40, 90),
	SecondaryElementStroke = Color3.fromRGB(40, 20, 60),

	SliderBackground = Color3.fromRGB(90, 50, 130),
	SliderProgress = Color3.fromRGB(255, 120, 50),
	SliderStroke = Color3.fromRGB(255, 160, 90),

	ToggleBackground = Color3.fromRGB(25, 20, 35),
	ToggleEnabled = Color3.fromRGB(255, 120, 50),
	ToggleDisabled = Color3.fromRGB(90, 70, 90),
	ToggleEnabledStroke = Color3.fromRGB(255, 160, 80),
	ToggleDisabledStroke = Color3.fromRGB(100, 80, 110),
	ToggleEnabledOuterStroke = Color3.fromRGB(70, 40, 20),
	ToggleDisabledOuterStroke = Color3.fromRGB(50, 30, 60),

	DropdownSelected = Color3.fromRGB(40, 25, 50),
	DropdownUnselected = Color3.fromRGB(30, 20, 40),

	InputBackground = Color3.fromRGB(25, 15, 35),
	InputStroke = Color3.fromRGB(70, 40, 90),
}
-- Rayfield UI (prefixed locals)
local BRVS_Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local BRVS_Window = BRVS_Rayfield:CreateWindow({
	Name = "Build A Zoo [🎃HW UPD 32] | HrafnHub",
	Icon = "egg",
	LoadingTitle = "Summoning spooky fishes...",
	LoadingSubtitle = "by HrafnHub 🎃",
	ShowText = "UI HrafnHub",
	Theme = BRVS_Theme,
	ToggleUIKeybind = "K",
	DisableRayfieldPrompts = true,
	DisableBuildWarnings = true,
	ConfigurationSaving = { Enabled = true, FolderName = "EggTools", FileName = "EggTools_Config" },
	Discord = { Enabled = false },
	KeySystem = false,
})

-- =================== TAB: Inventory (Paragraph-based) ===================
local BRVS_InvTab = BRVS_Window:CreateTab("Inventory", "box")
-- Paragraph element for Eggs
local BRVS_InvEggPara = BRVS_InvTab:CreateParagraph({ Title = "Eggs", Content = "loading..." })
local BRVS_InvEggConns, BRVS_InvEggPerItemConns = {}, {}
local function BRVS_ClearInvEggConns()
	for _, c in ipairs(BRVS_InvEggConns) do
		pcall(function()
			c:Disconnect()
		end)
	end
	BRVS_InvEggConns = {}
	for inst, list in pairs(BRVS_InvEggPerItemConns) do
		for _, c in ipairs(list) do
			pcall(function()
				c:Disconnect()
			end)
		end
		BRVS_InvEggPerItemConns[inst] = nil
	end
end
local function BRVS_HumanEggName(tVal)
	local base = tostring(tVal or "Unknown"):gsub("Egg$", "")
	if #base > 0 then
		base = base:sub(1, 1):upper() .. base:sub(2):lower()
	end
	return base .. " egg"
end
local function BRVS_RebuildEggInventoryText(eggsFolder)
	if not BRVS_InvEggPara then
		return
	end
	if not eggsFolder then
		BRVS_InvEggPara:Set({ Title = "Eggs", Content = "(none)" })
		return
	end
	local counts = {}
	for _, egg in ipairs(eggsFolder:GetChildren()) do
		if not egg:GetAttribute("D") then
			local T = egg:GetAttribute("T")
			local M = egg:GetAttribute("M")
			local key = tostring(T or "Unknown") .. "\0" .. tostring(M or "")
			counts[key] = (counts[key] or 0) + 1
		end
	end
	local lines = {}
	for key, n in pairs(counts) do
		local T, M = key:match("^(.-)\0(.*)$")
		local name = BRVS_HumanEggName(T)
		local line = (M and M ~= "") and string.format("• %s | %s  ×%d", name, M, n)
			or string.format("• %s  ×%d", name, n)
		table.insert(lines, line)
	end
	table.sort(lines, function(a, b)
		return a:lower() < b:lower()
	end)
	BRVS_InvEggPara:Set({ Title = "Eggs", Content = (#lines == 0) and "(none)" or table.concat(lines, "\n") })
end
local function BRVS_BindInventoryEggs()
	BRVS_ClearInvEggConns()
	local pg = BRVS_Player:WaitForChild("PlayerGui")
	local data = pg:WaitForChild("Data")
	local eggs = data:WaitForChild("Egg")
	BRVS_RebuildEggInventoryText(eggs)
	table.insert(
		BRVS_InvEggConns,
		eggs.ChildAdded:Connect(function(child)
			local list = {}
			table.insert(
				list,
				child:GetAttributeChangedSignal("T"):Connect(function()
					BRVS_RebuildEggInventoryText(eggs)
				end)
			)
			table.insert(
				list,
				child:GetAttributeChangedSignal("M"):Connect(function()
					BRVS_RebuildEggInventoryText(eggs)
				end)
			)
			table.insert(
				list,
				child:GetAttributeChangedSignal("D"):Connect(function()
					BRVS_RebuildEggInventoryText(eggs)
				end)
			)
			BRVS_InvEggPerItemConns[child] = list
			BRVS_RebuildEggInventoryText(eggs)
		end)
	)
	table.insert(
		BRVS_InvEggConns,
		eggs.ChildRemoved:Connect(function(child)
			local list = BRVS_InvEggPerItemConns[child]
			if list then
				for _, c in ipairs(list) do
					pcall(function()
						c:Disconnect()
					end)
				end
			end
			BRVS_InvEggPerItemConns[child] = nil
			BRVS_RebuildEggInventoryText(eggs)
		end)
	)
	for _, child in ipairs(eggs:GetChildren()) do
		local list = {}
		table.insert(
			list,
			child:GetAttributeChangedSignal("T"):Connect(function()
				BRVS_RebuildEggInventoryText(eggs)
			end)
		)
		table.insert(
			list,
			child:GetAttributeChangedSignal("M"):Connect(function()
				BRVS_RebuildEggInventoryText(eggs)
			end)
		)
		table.insert(
			list,
			child:GetAttributeChangedSignal("D"):Connect(function()
				BRVS_RebuildEggInventoryText(eggs)
			end)
		)
		BRVS_InvEggPerItemConns[child] = list
	end
end

-- Paragraph element for Food (above Eggs)
local BRVS_InvFoodPara = BRVS_InvTab:CreateParagraph({ Title = "Food", Content = "loading..." })
local BRVS_InvFoodConns = {}
local function BRVS_ClearInvFoodConns()
	for _, c in ipairs(BRVS_InvFoodConns) do
		pcall(function()
			c:Disconnect()
		end)
	end
	BRVS_InvFoodConns = {}
end
local function BRVS_RebuildFoodText(assetInst)
	if not BRVS_InvFoodPara then
		return
	end
	if not assetInst then
		BRVS_InvFoodPara:Set({ Title = "Food", Content = "(none)" })
		return
	end
	local lines = {}
	for _, name in ipairs(BRVS_FOOD_OPTIONS) do
		local v = assetInst:GetAttribute(name)
		if v ~= nil and v ~= false and v ~= 0 then
			if type(v) == "number" then
				if v > 0 then
					table.insert(lines, string.format("• %s  ×%d", name, v))
				end
			else
				table.insert(lines, string.format("• %s", name))
			end
		end
	end
	table.sort(lines, function(a, b)
		return a:lower() < b:lower()
	end)
	BRVS_InvFoodPara:Set({ Title = "Food", Content = (#lines == 0) and "(none)" or table.concat(lines, "\n") })
end
local function BRVS_BindInventoryFood()
	BRVS_ClearInvFoodConns()
	local pg = BRVS_Player:WaitForChild("PlayerGui")
	local data = pg:WaitForChild("Data")
	local asset = data:WaitForChild("Asset")
	BRVS_RebuildFoodText(asset)
	for _, name in ipairs(BRVS_FOOD_OPTIONS) do
		table.insert(
			BRVS_InvFoodConns,
			asset:GetAttributeChangedSignal(name):Connect(function()
				BRVS_RebuildFoodText(asset)
			end)
		)
	end
end

-- =================== TAB: Automation ===================
local BRVS_AutoTab = BRVS_Window:CreateTab("Automation", "rotate-cw")
local BRVS_IslandLabel =
	BRVS_AutoTab:CreateLabel(BRVS_IslandName and ("Island: " .. BRVS_IslandName) or "Island: (none)")
local BRVS_EggFilterPara =
	BRVS_AutoTab:CreateParagraph({ Title = "Egg Buy Filter", Content = "Names: Any\nMutations: Any" })
local function _fmtList(list)
	if not list or #list == 0 then
		return "Any"
	end
	for _, v in ipairs(list) do
		if v == "Any" then
			return "Any"
		end
	end
	return table.concat(list, ", ")
end
local function BRVS_UpdateEggFilterPara()
	if not BRVS_EggFilterPara then
		return
	end
	BRVS_EggFilterPara:Set({
		Title = "Egg Buy Filter",
		Content = ("Names: %s\nMutations: %s"):format(_fmtList(BRVS_SelEggNames), _fmtList(BRVS_SelMutations)),
	})
end

BRVS_AutoTab:CreateSection("Auto Buy Egg")
local BRVS_EggDD = BRVS_AutoTab:CreateDropdown({
	Name = "Name(s)",
	Options = BRVS_EGG_OPTIONS,
	CurrentOption = {},
	MultipleOptions = true,
	Flag = "EggNames",
	Callback = function(options)
		BRVS_SelEggNames = options or {}
		BRVS_PrintMatches()
		BRVS_RescanAutoBuy()
		BRVS_UpdateEggFilterPara()
	end,
})
local BRVS_MutDD = BRVS_AutoTab:CreateDropdown({
	Name = "Mutation(s)",
	Options = BRVS_MUTATION_OPTIONS,
	CurrentOption = {},
	MultipleOptions = true,
	Flag = "Mutations",
	Callback = function(options)
		BRVS_SelMutations = options or {}
		BRVS_PrintMatches()
		BRVS_RescanAutoBuy()
		BRVS_UpdateEggFilterPara()
	end,
})
local BRVS_AutoBuyToggle = BRVS_AutoTab:CreateToggle({
	Name = "Auto Buy Eggs",
	CurrentValue = false,
	Flag = "AutoBuy",
	Callback = function(on)
		BRVS_AutoBuyEnabled = on
		if BRVS_AutoBuyEnabled then
			BRVS_RescanAutoBuy()
			BRVS_Rayfield:Notify({ Title = "Auto Buy", Content = "Enabled", Duration = 4, Image = "shopping-bag" })
		else
			BRVS_Rayfield:Notify({ Title = "Auto Buy", Content = "Disabled", Duration = 3, Image = "ban" })
		end
	end,
})

BRVS_AutoTab:CreateSection("Auto Buy Food")
local BRVS_FoodSelPara = BRVS_AutoTab:CreateParagraph({ Title = "Food Buy Selection", Content = "(none)" })
local function BRVS_UpdateFoodSelPara()
	local foods = BRVS_SelectedFood or {}
	local text = (#foods == 0) and "(none)" or table.concat(foods, ", ")
	BRVS_FoodSelPara:Set({ Title = "Food Buy Selection", Content = text })
end
local BRVS_FoodDD = BRVS_AutoTab:CreateDropdown({
	Name = "Food (multi-select)",
	Options = BRVS_FOOD_OPTIONS,
	CurrentOption = {},
	MultipleOptions = true,
	Flag = "FoodSelect",
	Callback = function(options)
		BRVS_SelectedFood = options or {}
		BRVS_UpdateFoodSelPara()
	end,
})
local BRVS_AutoBuyFoodToggle = BRVS_AutoTab:CreateToggle({
	Name = "Auto Buy Food",
	CurrentValue = false,
	Flag = "AutoBuyFood",
	Callback = function(on)
		BRVS_FoodBuyEnabled = on
		BRVS_FoodBuyThread = nil
		if not BRVS_FoodBuyEnabled then
			BRVS_Rayfield:Notify({ Title = "Food Store", Content = "Auto Buy Food: OFF", Duration = 2.5, Image = "ban" })
			return
		end
		BRVS_FoodBuyThread = task.spawn(function()
			BRVS_Rayfield:Notify({
				Title = "Food Store",
				Content = "Auto Buy Food: ON",
				Duration = 2.5,
				Image = "shopping-cart",
			})
			while BRVS_FoodBuyEnabled do
				local foods = (BRVS_SelectedFood and #BRVS_SelectedFood > 0) and BRVS_SelectedFood or {}
				local remote = BRVS_GetRemote(BRVS_FOOD_REMOTE_PATH)
				if #foods > 0 and remote and remote:IsA("RemoteEvent") then
					for _, item in ipairs(foods) do
						if not BRVS_FoodBuyEnabled then
							break
						end
						if BRVS_HasFoodStock(item) then
							remote:FireServer(item)
							task.wait(0.05)
						end
					end
				end
				task.wait(BRVS_FoodBuyInterval)
			end
		end)
	end,
})

BRVS_AutoTab:CreateSection("Auto Collect Pet")
local BRVS_PetDelaySlider = BRVS_AutoTab:CreateSlider({
	Name = "Pet Delay",
	Range = { 1, 60 },
	Increment = 1,
	Suffix = "sec",
	CurrentValue = BRVS_PetCollectInterval,
	Flag = "PetCollectDelay",
	Callback = function(val)
		BRVS_PetCollectInterval = tonumber(val) or BRVS_PetCollectInterval
	end,
})

local function BRVS_ClaimMyPetsOnce(ratePerSec)
	ratePerSec = math.max(1, tonumber(ratePerSec) or 15)
	local token = bit32.bxor(BRVS_UserId, BRVS_token:GetAttribute("s"), BRVS_token.Value)

	local interval = 1 / ratePerSec
	local pg = BRVS_Player:FindFirstChildOfClass("PlayerGui")
	if not pg then
		return
	end
	local data = pg:FindFirstChild("Data")
	if not data then
		return
	end
	local petsNode = data:FindFirstChild("Pets")
	if not petsNode then
		return
	end
	local workspacePets = BRVS_Workspace:FindFirstChild("Pets")
	if not workspacePets then
		return
	end

	local owned = {}
	for _, obj in ipairs(petsNode:GetChildren()) do
		local uid = (obj:IsA("StringValue") and obj.Value ~= "" and obj.Value) or obj.Name
		if type(uid) == "string" and uid ~= "" then
			owned[uid] = true
		end
	end
	if not next(owned) then
		return
	end

	local reByUID = {}
	for _, model in ipairs(workspacePets:GetChildren()) do
		if model:IsA("Part") then
			local root = model:FindFirstChild("RE")
			if root and root.FireServer then
				reByUID[model.Name] = root
			end
		end
	end

	local function firePaced(queue)
		local nextTime = os.clock()
		for i = 1, #queue do
			local re = queue[i]
			if re and re.FireServer then
				local now = os.clock()
				if now < nextTime then
					task.wait(nextTime - now)
				end
				re:FireServer("Claim", token)
				nextTime = nextTime + interval
			end
		end
	end

	local queue = {}
	for uid in pairs(owned) do
		local re = reByUID[uid]
		if re then
			queue[#queue + 1] = re
		end
	end
	if #queue > 0 then
		firePaced(queue)
	end

	local missing = {}
	for uid in pairs(owned) do
		if not reByUID[uid] then
			missing[#missing + 1] = uid
		end
	end
	if #missing > 0 then
		task.wait(0.2)
		local retryQueue = {}
		for _, uid in ipairs(missing) do
			local model = workspacePets:FindFirstChild(uid)
			if model and model:IsA("Model") then
				local root = model:FindFirstChild("RootPart")
				local re = root and root:FindFirstChild("RE")
				if re and re.FireServer then
					retryQueue[#retryQueue + 1] = re
				end
			end
		end
		if #retryQueue > 0 then
			firePaced(retryQueue)
		end
	end
end

local BRVS_PetToggle = BRVS_AutoTab:CreateToggle({
	Name = "Auto Collect Pet",
	CurrentValue = false,
	Flag = "PetCollectToggle",
	Callback = function(on)
		BRVS_PetCollectEnabled = on
		BRVS_PetCollectThread = nil
		if not BRVS_PetCollectEnabled then
			return
		end
		BRVS_PetCollectThread = task.spawn(function()
			while BRVS_PetCollectEnabled do
				BRVS_ClaimMyPetsOnce()
				local t = math.max(0.1, BRVS_PetDelaySlider.CurrentValue or BRVS_PetCollectInterval or 3)
				local elapsed = 0
				while BRVS_PetCollectEnabled and elapsed < t do
					task.wait(0.1)
					elapsed = elapsed + 0.1
				end
			end
		end)
	end,
})

-- ====== Auto Fish (scoped) =================
do
	BRVS_AutoTab:CreateSection("Auto Fish")

	-- Reuse BRVS_ReplicatedStorage (no RS local)
	local CharacterRE = BRVS_ReplicatedStorage:WaitForChild("Remote"):WaitForChild("CharacterRE")
	local FishingRE = BRVS_ReplicatedStorage:WaitForChild("Remote"):WaitForChild("FishingRE")
	local ResourceRE = BRVS_ReplicatedStorage:WaitForChild("Remote"):WaitForChild("ResourceRE")

	local FISH_CFRAME = CFrame.new(
		-534.689209,
		16.9160748,
		206.973068,
		-0.999972939,
		4.14041921e-08,
		0.00735867722,
		4.164934e-08,
		1,
		3.31608945e-08,
		-0.00735867722,
		3.34664811e-08,
		-0.999972939
	)
	local THROW_POS = Vector3.new(-534.799560546875, 11, 231.97265625)
	local BRVS_FishBait = BRVS_FishBait or "FishingBait3"
	local dFocus, dThrow, dPull = 0.4, 1.0, 0.50
	local BRVS_FishEnabled = false

	local function HRP()
		local c = BRVS_Player.Character
		return c and c:FindFirstChild("HumanoidRootPart") or nil
	end
	local function ensureSpot()
		local p = HRP()
		if not p then
			BRVS_Rayfield:Notify({ Title = "Auto Fish", Content = "Waiting for character…", Duration = 1 })
			return false
		end
		local dist = (p.Position - FISH_CFRAME.Position).Magnitude
		local dirDelta = (p.CFrame.LookVector - FISH_CFRAME.LookVector).Magnitude
		if dist > 0.1 or dirDelta > 1e-3 then
			p.AssemblyLinearVelocity = Vector3.zero
			p.CFrame = FISH_CFRAME
			task.wait(0.5)
		end
		return true
	end
	local function BRVS_IsFishingActive()
		local fishPoint = workspace:FindFirstChild("FishPoints")
		if not fishPoint then
			return false
		end
		for _, fp in ipairs(fishPoint:GetChildren()) do
			if fp:FindFirstChild("FX_Fish_Special", true) then
				return true
			end
		end
		return false
	end

	-- === UPDATED one cycle ===
	local function BRVS_OneFishCycle()
		-- Short-circuit if fishing area inactive or not at the spot (your original checks)
		if not BRVS_IsFishingActive() then
			task.wait(0.8)
			return
		end
		if not ensureSpot() then
			return
		end

		-- Your existing cadence: reinforce focus a few times, then Throw, Pull, POUT loop
		for _ = 1, 3 do
			CharacterRE:FireServer("Focus", "FishRob")
			task.wait(dFocus)
		end
		FishingRE:FireServer("Throw", { Bait = BRVS_FishBait, Pos = THROW_POS })
		task.wait(dThrow)
		pcall(function()
			ResourceRE:FireServer("PULL", "FX/FX_Fish")
		end)
		for _ = 1, 10 do
			FishingRE:FireServer("POUT", { SUC = 1 })
			task.wait(dPull)
		end
	end

	BRVS_AutoTab:CreateToggle({
		Name = "Auto Fish (new method)",
		CurrentValue = false,
		Flag = "AutoFish_New",
		Callback = function(on)
			BRVS_FishEnabled = on
			if on then
				BRVS_Rayfield:Notify({ Title = "Auto Fish", Content = "Enabled (new)", Duration = 1, Image = "fish" })
				task.spawn(function()
					while BRVS_FishEnabled do
						BRVS_OneFishCycle()
						task.wait(0.3)
					end
				end)
			else
				BRVS_Rayfield:Notify({ Title = "Auto Fish", Content = "Disabled", Duration = 1, Image = "ban" })
			end
		end,
	})
end
local BRVS_EventTab = BRVS_Window:CreateTab("Event", "ferris-wheel")
-- ====== Dino Event Auto-Claim (scoped) ======
do
	BRVS_EventTab:CreateSection("Auto Event Claimer")

	local BRVS_DinoEventRE = BRVS_ReplicatedStorage:WaitForChild("Remote"):WaitForChild("DinoEventRE")

	local function BRVS_GetDinoTasksFolder(timeout)
		timeout = timeout or 10
		local pg = BRVS_Player:FindFirstChildOfClass("PlayerGui")
		if not pg then
			return nil
		end
		local data = pg:FindFirstChild("Data")
		if not data then
			return nil
		end

		local dino = data:FindFirstChild("DinoEventTaskData")
		if not dino then
			dino = data:WaitForChild("DinoEventTaskData", timeout)
		end
		if not dino then
			return nil
		end

		local tasks = dino:FindFirstChild("Tasks")
		if not tasks then
			tasks = dino:WaitForChild("Tasks", timeout)
		end
		return tasks
	end

	local function BRVS_LoadResDino()
		local ok, res = pcall(function()
			local cfg = BRVS_ReplicatedStorage:FindFirstChild("Config")
			local mod = cfg and cfg:FindFirstChild("ResDinoEventTask")
			return mod and require(mod) or nil
		end)
		if ok and type(res) == "table" then
			return res
		end
		return {
			["Task_1"] = { Id = "Task_1", CompleteValue = 5, RepeatCount = 1 },
			["Task_2"] = { Id = "Task_2", CompleteValue = 1, RepeatCount = 1 },
			["Task_3"] = { Id = "Task_3", CompleteValue = 1, RepeatCount = 1 },
			["Task_5"] = { Id = "Task_5", CompleteValue = 5, RepeatCount = 1 },
			["Task_7"] = { Id = "Task_7", CompleteValue = 3, RepeatCount = 1 },
			["Task_8"] = { Id = "Task_8", CompleteValue = 1200, RepeatCount = 4 },
			["__index"] = { "Task_1", "Task_2", "Task_3", "Task_5", "Task_7", "Task_8" },
		}
	end

	local BRVS_ResDino = BRVS_LoadResDino()
	local BRVS_DinoTargetById, BRVS_DinoRepeatById = {}, {}
	for _, row in pairs(BRVS_ResDino) do
		if type(row) == "table" and row.Id then
			BRVS_DinoTargetById[row.Id] = tonumber(row.CompleteValue) or 1
			BRVS_DinoRepeatById[row.Id] = tonumber(row.RepeatCount) or 1
		end
	end

	local function BRVS_AsNumber(v)
		local t = typeof(v)
		if t == "number" then
			return v
		end
		if t == "string" then
			return tonumber(v)
		end
		if t == "NumberRange" then
			return v.Max
		end
		return nil
	end
	local function BRVS_ReadId(task)
		if not task then
			return nil
		end
		local c = task:FindFirstChild("Id")
		if c and c.Value ~= nil then
			return tostring(c.Value)
		end
		local a = task:GetAttribute("Id")
		if a ~= nil then
			return tostring(a)
		end
		if task.Name == "1" then
			return "Task_1"
		elseif task.Name == "2" then
			return "Task_2"
		elseif task.Name == "3" then
			return "Task_3"
		end
		return nil
	end
	local function BRVS_ReadProgress(task)
		if not task then
			return nil
		end
		local p = task:FindFirstChild("Progress")
		if p and p.Value ~= nil then
			return BRVS_AsNumber(p.Value)
		end
		local a = task:GetAttribute("Progress")
		if a ~= nil then
			return BRVS_AsNumber(a)
		end
		return nil
	end
	local function BRVS_ReadClaimedCount(task)
		if not task then
			return nil
		end
		local a = task:GetAttribute("ClaimedCount")
		if a ~= nil then
			return tonumber(a)
		end
		local v = task:FindFirstChild("ClaimedCount")
		if v and v.Value ~= nil then
			return tonumber(v.Value)
		end
		return nil
	end
	local function BRVS_IsIntEqual(x, target)
		return x ~= nil and (math.floor(x + 0.5) == target)
	end

	local BRVS_DinoConns = {}
	local BRVS_DinoLastFired = setmetatable({}, { __mode = "k" })
	local BRVS_DinoEnabled = false

	local function BRVS_DinoClearConns()
		for _, c in ipairs(BRVS_DinoConns) do
			pcall(function()
				c:Disconnect()
			end)
		end
		table.clear(BRVS_DinoConns)
	end

	local BRVS_DinoStatus = BRVS_EventTab:CreateLabel("Event Auto-Claim: OFF")
	local function BRVS_DinoSetStatus(text)
		if BRVS_DinoStatus and typeof(BRVS_DinoStatus.Set) == "function" then
			BRVS_DinoStatus:Set(text)
		end
	end

	local function BRVS_DinoMaybeFire(task, silent)
		local id = BRVS_ReadId(task)
		if not id then
			return
		end
		local prg = BRVS_ReadProgress(task)
		if prg == nil then
			return
		end

		local target = BRVS_DinoTargetById[id] or 1
		local repeatCount = BRVS_DinoRepeatById[id] or 1
		local claimed = BRVS_ReadClaimedCount(task) or 0

		local isClaimedCheck = (id == "Task_1" or id == "Task_2" or id == "Task_3")
		local key
		if isClaimedCheck then
			if claimed == repeatCount then
				BRVS_DinoLastFired[task] = claimed
				return
			end
			key = claimed
			if BRVS_DinoLastFired[task] == key then
				return
			end
		else
			key = true
			if BRVS_DinoLastFired[task] == key then
				return
			end
		end

		if BRVS_IsIntEqual(prg, target) then
			local payload = { event = "claimreward", id = id }
			local ok, err = pcall(function()
				BRVS_DinoEventRE:FireServer(payload)
			end)
			BRVS_DinoLastFired[task] = key
			if not silent then
				if ok then
					BRVS_Rayfield:Notify({
						Title = "Event",
						Content = ("Claimed %s (%s/%s)"):format(id, tostring(prg), tostring(target)),
						Duration = 2.5,
						Image = "check",
					})
				else
					BRVS_Rayfield:Notify({
						Title = "Event",
						Content = ("Error claiming %s: %s"):format(id, tostring(err)),
						Duration = 3.5,
						Image = "alert-triangle",
					})
				end
			end
		end
	end

	local function BRVS_DinoHookTask(task)
		BRVS_DinoMaybeFire(task, true)
		local p = task:FindFirstChild("Progress")
		if p and p.GetPropertyChangedSignal then
			table.insert(
				BRVS_DinoConns,
				p:GetPropertyChangedSignal("Value"):Connect(function()
					if BRVS_DinoEnabled then
						BRVS_DinoMaybeFire(task)
					end
				end)
			)
		end
		if task.GetAttributeChangedSignal then
			table.insert(
				BRVS_DinoConns,
				task:GetAttributeChangedSignal("Progress"):Connect(function()
					if BRVS_DinoEnabled then
						BRVS_DinoMaybeFire(task)
					end
				end)
			)
			table.insert(
				BRVS_DinoConns,
				task:GetAttributeChangedSignal("ClaimedCount"):Connect(function()
					if BRVS_DinoEnabled then
						BRVS_DinoMaybeFire(task)
					end
				end)
			)
		end
		local cc = task:FindFirstChild("ClaimedCount")
		if cc and cc.GetPropertyChangedSignal then
			table.insert(
				BRVS_DinoConns,
				cc:GetPropertyChangedSignal("Value"):Connect(function()
					if BRVS_DinoEnabled then
						BRVS_DinoMaybeFire(task)
					end
				end)
			)
		end
	end

	local function BRVS_DinoStart()
		if BRVS_DinoEnabled then
			return
		end
		BRVS_DinoEnabled = true
		table.clear(BRVS_DinoLastFired)
		BRVS_DinoClearConns()

		local folder = BRVS_GetDinoTasksFolder(10)
		if not folder then
			BRVS_Rayfield:Notify({
				Title = "Event",
				Content = "Tasks not ready, retrying…",
				Duration = 2,
				Image = "alert-triangle",
			})
			task.delay(2, function()
				if BRVS_DinoEnabled then
					BRVS_DinoStart()
				end
			end)
			return
		end

		for _, num in ipairs({ "1", "2", "3" }) do
			local node = folder:FindFirstChild(num)
			if node then
				BRVS_DinoHookTask(node)
			end
		end
		table.insert(
			BRVS_DinoConns,
			folder.ChildAdded:Connect(function(ch)
				if ch.Name == "1" or ch.Name == "2" or ch.Name == "3" then
					BRVS_DinoHookTask(ch)
				end
			end)
		)

		BRVS_DinoSetStatus("Event Auto-Claim: ON")
		BRVS_Rayfield:Notify({ Title = "Event", Content = "Auto-Claim enabled", Duration = 2, Image = "check" })
	end

	local function BRVS_DinoStop()
		if not BRVS_DinoEnabled then
			return
		end
		BRVS_DinoEnabled = false
		BRVS_DinoClearConns()
		BRVS_DinoSetStatus("Event Auto-Claim: OFF")
		BRVS_Rayfield:Notify({ Title = "Event", Content = "Auto-Claim disabled", Duration = 2, Image = "ban" })
	end

	local BRVS_DinoToggle = BRVS_EventTab:CreateToggle({
		Name = "Auto-Claim Tasks",
		CurrentValue = false,
		Flag = "DinoAutoClaim",
		Callback = function(on)
			if on then
				BRVS_DinoStart()
			else
				BRVS_DinoStop()
			end
		end,
	})

	-- Restore state after LoadConfiguration
	task.defer(function()
		if BRVS_DinoToggle and BRVS_DinoToggle.CurrentValue then
			BRVS_DinoStart()
		end
	end)
end

-- ====== Auto Recall & Auto Place (scoped) ======
do
	local BRVS_AutoRecallTab = BRVS_Window:CreateTab("Auto Recall", "monitor-dot")
	BRVS_AutoRecallTab:CreateSection("Auto Recall")

	local function BRVS_RecallAll_ExcludeBPV_RequireD_PG()
		local re = BRVS_GetCharacterRE()
		if not (re and re:IsA("RemoteEvent")) then
			return
		end
		local lp = BRVS_Players.LocalPlayer
		local pg = lp and lp:FindFirstChildOfClass("PlayerGui")
		local data = pg and pg:FindFirstChild("Data")
		local pets = data and data:FindFirstChild("Pets")
		local takens = bit32.bxor(BRVS_UserId, BRVS_token:GetAttribute("s"), BRVS_token.Value)
		if not pets then
			return
		end
		local function toNum(x)
			if typeof(x) == "number" then
				return x
			end
			if typeof(x) == "string" then
				return tonumber(x)
			end
			return nil
		end
		local function hasTruthyD(obj)
			local d = obj:GetAttribute("D")
			if d == nil then
				return false
			end
			if typeof(d) == "boolean" then
				return d
			end
			if typeof(d) == "number" then
				return d ~= 0
			end
			if typeof(d) == "string" then
				d = d:lower()
				return d == "1" or d == "true"
			end
			return true
		end
		for _, child in ipairs(pets:GetChildren()) do
			local uid = child.Name
			if typeof(uid) == "string" and #uid > 0 then
				local bpv = toNum(child:GetAttribute("BPV"))
				if hasTruthyD(child) and (bpv == nil) then
					-- BRVS_GetCharacterRE:FireServer("Del", uid, takens)
					local manuke = {
						"Del",
						uid,
						takens,
					}
					game:GetService("ReplicatedStorage")
						:FindFirstChild("Remote")
						:FindFirstChild("CharacterRE")
						:FireServer(unpack(manuke))
					task.wait(0.2)
				end
			end
		end
	end
	BRVS_AutoRecallTab:CreateButton({ Name = "Recall All", Callback = BRVS_RecallAll_ExcludeBPV_RequireD_PG })

	----------------------------------------------------------------
	-- Auto Place by PetProduce (No D, No BPV)
	----------------------------------------------------------------
	local MY_UID = BRVS_UserId

	local function BRVS_VectorCreate(x, y, z)
		return vector.create(x, y, z)
	end
	local function BRVS_GetMyIsland()
		local art = workspace:FindFirstChild("Art")
		if not art then
			return nil
		end
		for i = 1, 12 do
			local island = art:FindFirstChild("Island_" .. i)
			if island and island:GetAttribute("OccupyingPlayerId") == MY_UID then
				return island, i
			end
		end
		return nil
	end
	local function BRVS_GetRootCF(root)
		if not root then
			return CFrame.new()
		end
		if root:IsA("Model") then
			local ok, cf = pcall(function()
				return root:GetPivot()
			end)
			return ok and cf or CFrame.new()
		elseif root:IsA("BasePart") then
			return root.CFrame
		else
			local p = root:FindFirstChildWhichIsA("BasePart", true)
			return p and p.CFrame or CFrame.new()
		end
	end
	local function BRVS_GetInstCF(inst)
		if not inst then
			return nil
		end
		if inst:IsA("Model") then
			local ok, cf = pcall(function()
				return inst:GetPivot()
			end)
			return ok and cf or nil
		elseif inst:IsA("BasePart") then
			return inst.CFrame
		else
			local p = inst:FindFirstChildWhichIsA("BasePart", true)
			return p and p.CFrame or nil
		end
	end
	local function BRVS_TileToDST(tileInst)
		local cf = BRVS_GetInstCF(tileInst)
		if not cf then
			return nil
		end
		local p = cf.Position
		return BRVS_VectorCreate(p.X, p.Y + 4, p.Z)
	end
	local function BRVS_CollectSortedTilesForMe(pattern)
		local root = select(1, BRVS_GetMyIsland())
		if not root then
			warn("[BRVS] You don't have a claimed island right now.")
			return {}
		end
		local rootCF = BRVS_GetRootCF(root)
		local ROW_TOL = 0.25
		local tiles = {}
		for _, ch in ipairs(root:GetChildren()) do
			if ch.Name:match(pattern) then
				local cf = BRVS_GetInstCF(ch)
				if cf then
					local lp = rootCF:PointToObjectSpace(cf.Position)
					tiles[#tiles + 1] = { inst = ch, wp = cf.Position, lp = lp }
				end
			end
		end
		table.sort(tiles, function(a, b)
			if math.abs(a.lp.Z - b.lp.Z) > ROW_TOL then
				return a.lp.Z < b.lp.Z
			end
			if a.lp.X ~= b.lp.X then
				return a.lp.X < b.lp.X
			end
			if a.lp.Y ~= b.lp.Y then
				return a.lp.Y < b.lp.Y
			end
			return a.inst.Name < b.inst.Name
		end)
		return tiles
	end
	local function BRVS_GetFarmTilesForMe()
		return BRVS_CollectSortedTilesForMe("^Farm_split_(%d+)_(%d+)_(%d+)$")
	end
	local function BRVS_GetWaterFarmTilesForMe()
		return BRVS_CollectSortedTilesForMe("^WaterFarm_split_(%d+)_(%d+)_(%d+)$")
	end
	local function BRVS_TileLooksOccupied(tile)
		if not tile then
			return true
		end
		local uidAttr = tile:GetAttribute("UID") or tile:GetAttribute("PetUID")
		if uidAttr and uidAttr ~= "" then
			return true
		end
		local sv = tile:FindFirstChild("UID") or tile:FindFirstChild("PetUID")
		if sv and sv:IsA("StringValue") and sv.Value ~= "" then
			return true
		end
		for _, ch in ipairs(tile:GetChildren()) do
			if ch:IsA("Model") or ch:IsA("BasePart") then
				return true
			end
		end
		return false
	end

	local BRVS_PetModule
	local function BRVS_GetPetModule()
		if BRVS_PetModule then
			return BRVS_PetModule
		end
		local rs = BRVS_ReplicatedStorage
		local util = rs:FindFirstChild("Util")
		if util and util:FindFirstChild("Pet") then
			BRVS_PetModule = require(util.Pet)
			return BRVS_PetModule
		end
		if rs:FindFirstChild("Pet") then
			BRVS_PetModule = require(rs.Pet)
			return BRVS_PetModule
		end
		warn("[BRVS] Pet module not found; update BRVS_GetPetModule() path.")
		return nil
	end
	local function BRVS_GetPGPetsFolder()
		local pg = BRVS_Player and BRVS_Player:FindFirstChildOfClass("PlayerGui")
		local data = pg and pg:FindFirstChild("Data")
		return data and data:FindFirstChild("Pets") or nil
	end
	local function BRVS_MakePetDataFromPG(petInst)
		local t = petInst:GetAttribute("T")
		if not t then
			return nil
		end
		local pet = {
			T = t,
			M = petInst:GetAttribute("M"),
			BPV = petInst:GetAttribute("BPV"),
			BPT = petInst:GetAttribute("BPT"),
			V = petInst:GetAttribute("V"),
		}
		for name, value in pairs(petInst:GetAttributes()) do
			if typeof(name) == "string" and name:match("^MT_") then
				pet[name] = value
			end
		end
		return pet
	end
	local function hasTruthyD(petInst)
		local d = petInst:GetAttribute("D")
		if d == nil then
			return false
		end
		local t = typeof(d)
		if t == "boolean" then
			return d
		end
		if t == "number" then
			return d ~= 0
		end
		if t == "string" then
			d = d:lower()
			return d == "1" or d == "true"
		end
		return true
	end
	local function hasBPVAttr(petInst)
		local v = petInst:GetAttribute("BPV")
		if v == nil then
			return false
		end
		if typeof(v) == "number" then
			return true
		end
		if typeof(v) == "string" then
			return tonumber(v) ~= nil
		end
		return true
	end
	local function BRVS_IsEligibleForPlace(petInst)
		return (not hasTruthyD(petInst)) and (not hasBPVAttr(petInst))
	end
	local BRVS_ResPet
	local function BRVS_GetResPet()
		if BRVS_ResPet then
			return BRVS_ResPet
		end
		local cfg = BRVS_ReplicatedStorage:WaitForChild("Config")
		BRVS_ResPet = require(cfg:WaitForChild("ResPet"))
		return BRVS_ResPet
	end
	local function BRVS_KindForPetInst(petInst, petData)
		local k = petInst:GetAttribute("BPT")
		if k == "Fish" or k == "Normal" then
			return k
		end
		local t = (petData and petData.T) or petInst:GetAttribute("T")
		if type(t) == "string" then
			local ResPet = BRVS_GetResPet()
			local row = ResPet and ResPet[t]
			if row then
				if tostring(row.Category or ""):lower() == "ocean" then
					return "Fish"
				end
				local idle = tostring(row.IdleSFX or ""):lower()
				if idle:find("fish") then
					return "Fish"
				end
				local lname = t:lower()
				if
					lname:find("fish")
					or lname:find("eel")
					or lname:find("octopus")
					or lname:find("tuna")
					or lname:find("shark")
					or lname:find("whale")
					or lname:find("dolphin")
					or lname:find("manta")
				then
					return "Fish"
				end
				return "Normal"
			end
		end
		return "Normal"
	end
	local function BRVS_CollectPetsWithProduce(rateMul)
		rateMul = rateMul or 1
		local petsFolder = BRVS_GetPGPetsFolder()
		local Pet = BRVS_GetPetModule()
		if not (petsFolder and Pet and Pet.GetPetProduce) then
			return {}
		end
		local out = {}
		for _, child in ipairs(petsFolder:GetChildren()) do
			if BRVS_IsEligibleForPlace(child) then
				local data = BRVS_MakePetDataFromPG(child)
				if data then
					local ok, prod = pcall(function()
						return Pet:GetPetProduce(data, rateMul)
					end)
					out[#out + 1] = {
						uid = child.Name,
						inst = child,
						data = data,
						kind = BRVS_KindForPetInst(child, data),
						produce = (ok and prod) or 0,
					}
				end
			end
		end
		table.sort(out, function(a, b)
			if a.produce == b.produce then
				return a.uid < b.uid
			end
			return a.produce > b.produce
		end)
		return out
	end
	local PLACE_PACE = 0.3
	local function BRVS_FireFocus(uid)
		local re = BRVS_GetCharacterRE()
		if not re then
			return
		end
		if uid then
			re:FireServer("Focus", uid)
		else
			re:FireServer("Focus")
		end
	end
	local function BRVS_FirePlace(uid, tileInst)
		local re = BRVS_GetCharacterRE()
		if not (re and uid and tileInst) then
			return false
		end
		local dst = BRVS_TileToDST(tileInst)
		if not dst then
			return false
		end
		BRVS_FireFocus(uid)
		task.wait(PLACE_PACE)
		re:FireServer("Place", { DST = dst, ID = uid })
		task.wait(PLACE_PACE)
		BRVS_FireFocus(nil)
		return true
	end
	local function BRVS_AutoPlaceByProduceNow()
		local items = BRVS_CollectPetsWithProduce(1)
		if #items == 0 then
			warn("[BRVS] No eligible pets to place (must NOT have D and NOT BPV).")
			return 0
		end
		local freeFarm, freeWater = {}, {}
		for _, t in ipairs(BRVS_GetFarmTilesForMe()) do
			if not BRVS_TileLooksOccupied(t.inst) then
				freeFarm[#freeFarm + 1] = t.inst
			end
		end
		for _, t in ipairs(BRVS_GetWaterFarmTilesForMe()) do
			if not BRVS_TileLooksOccupied(t.inst) then
				freeWater[#freeWater + 1] = t.inst
			end
		end
		local iFarm, iWater, placed = 1, 1, 0
		for _, row in ipairs(items) do
			if row.kind == "Normal" and iFarm <= #freeFarm then
				if BRVS_FirePlace(row.uid, freeFarm[iFarm]) then
					iFarm = iFarm + 1
					placed = placed + 1
				end
			end
			if iFarm > #freeFarm then
				break
			end
		end
		for _, row in ipairs(items) do
			if row.kind == "Fish" and iWater <= #freeWater then
				if BRVS_FirePlace(row.uid, freeWater[iWater]) then
					iWater = iWater + 1
					placed = placed + 1
				end
			end
			if iWater > #freeWater then
				break
			end
		end
		print(("[BRVS] AutoPlaceByProduce placed %d pets (Normals first, then Fish)"):format(placed))
		return placed
	end

	BRVS_AutoRecallTab:CreateSection("Auto Place (by PetProduce)")
	local AP_PlaceNowToggle
	AP_PlaceNowToggle = BRVS_AutoRecallTab:CreateToggle({
		Name = "Place Now (desc by Produce) — No D, No BPV",
		CurrentValue = false,
		Flag = "AP_PlaceNowDescToggle",
		Callback = function(state)
			if state then
				local placed = BRVS_AutoPlaceByProduceNow()
				BRVS_Rayfield:Notify({
					Title = "Auto Place",
					Content = ("Placed %d pets (No D, No BPV)"):format(placed or 0),
					Duration = 1,
					Image = "check",
				})
				if AP_PlaceNowToggle and typeof(AP_PlaceNowToggle.Set) == "function" then
					task.defer(function()
						AP_PlaceNowToggle:Set(false)
					end)
				end
			end
		end,
	})
end

-- =================== TAB: Auto Hatch ===================
local BRVS_AutoHatchTab = BRVS_Window:CreateTab("Auto Hatch", "egg-off")
BRVS_AutoHatchTab:CreateSection("Auto Hatch (on mark)")
local BRVS_HatchEnabled = false
local BRVS_HatchLabel = nil
local PLAYER_BLOCKS = BRVS_Workspace:FindFirstChild("PlayerBuiltBlocks")
local BRVS_HatchConns = {}
local function _clearHatchConns()
	for _, c in ipairs(BRVS_HatchConns) do
		pcall(function()
			c:Disconnect()
		end)
	end
	BRVS_HatchConns = {}
end
local function LooksLikeEgg(m)
	return m and m:IsA("Model") and m:GetAttribute("UserId") ~= nil and (m:FindFirstChild("RootPart", true) ~= nil)
end
local function OwnedByLocal(m)
	return m:GetAttribute("UserId") == BRVS_UserId
end
local function HasMark(m)
	return m:FindFirstChild("ExclamationMark", true) ~= nil
end
local function GetRF(m)
	local rf = m:FindFirstChild("RF")
	if rf and rf:IsA("RemoteFunction") then
		return rf
	end
	rf = m:FindFirstChild("RF", true)
	if rf and rf:IsA("RemoteFunction") then
		return rf
	end
	return nil
end
local function BRVS_StartHatchWorker()
	if not PLAYER_BLOCKS then
		return
	end
	local hatchedCount = 0
	local inFlight = setmetatable({}, { __mode = "k" })
	local finished = setmetatable({}, { __mode = "k" })
	task.spawn(function()
		while BRVS_HatchEnabled do
			local text = string.format("Status: %s | Hatched: %d", "Running", hatchedCount)
			if BRVS_HatchLabel then
				BRVS_HatchLabel:Set(text)
			end
			task.wait(1)
		end
		if BRVS_HatchLabel then
			BRVS_HatchLabel:Set("Status: Disabled")
		end
	end)
	local function HatchOnce(egg)
		if not BRVS_HatchEnabled then
			return
		end
		if not egg or not egg.Parent then
			return
		end
		if inFlight[egg] or finished[egg] then
			return
		end
		if not (LooksLikeEgg(egg) and OwnedByLocal(egg) and HasMark(egg)) then
			return
		end
		local rf = GetRF(egg)
		if not rf then
			return
		end
		inFlight[egg] = true
		task.spawn(function()
			local ok, success = pcall(function()
				return rf:InvokeServer("Hatch")
			end)
			if ok and success == true then
				finished[egg] = true
				hatchedCount = hatchedCount + 1
			end
			inFlight[egg] = nil
		end)
	end
	for _, inst in ipairs(PLAYER_BLOCKS:GetDescendants()) do
		if inst:IsA("Model") and LooksLikeEgg(inst) and OwnedByLocal(inst) and HasMark(inst) then
			HatchOnce(inst)
		end
	end
	local function hookModel(m)
		if not m or not m:IsA("Model") then
			return
		end
		if LooksLikeEgg(m) and OwnedByLocal(m) and HasMark(m) then
			HatchOnce(m)
		end
		local con = m.DescendantAdded:Connect(function(d)
			if not BRVS_HatchEnabled then
				return
			end
			if d.Name == "ExclamationMark" then
				local egg = d:FindFirstAncestorOfClass("Model")
				if egg then
					HatchOnce(egg)
				end
			end
		end)
		table.insert(BRVS_HatchConns, con)
	end
	table.insert(
		BRVS_HatchConns,
		PLAYER_BLOCKS.DescendantAdded:Connect(function(inst)
			if not BRVS_HatchEnabled then
				return
			end
			if inst:IsA("Model") then
				hookModel(inst)
			elseif inst.Name == "ExclamationMark" then
				local egg = inst:FindFirstAncestorOfClass("Model")
				if egg then
					HatchOnce(egg)
				end
			end
		end)
	)
end
local function BRVS_StopHatchWorker()
	BRVS_HatchEnabled = false
	_clearHatchConns()
	if BRVS_HatchLabel then
		BRVS_HatchLabel:Set("Status: Disabled")
	end
end
BRVS_AutoHatchTab:CreateToggle({
	Name = "Auto Hatch (on mark)",
	CurrentValue = false,
	Flag = "AutoHatchOnMark",
	Callback = function(on)
		if on then
			if BRVS_HatchEnabled then
				return
			end
			BRVS_HatchEnabled = true
			BRVS_StartHatchWorker()
		else
			BRVS_StopHatchWorker()
		end
	end,
})
BRVS_HatchLabel = BRVS_AutoHatchTab:CreateLabel("Status: Disabled")

-- =================== TAB: Utils ===================
local BRVS_UtilsTab = BRVS_Window:CreateTab("Utils", "sliders")
BRVS_UtilsTab:CreateSection("Ultra Low")
local BRVS_UltraLowToggle = BRVS_UtilsTab:CreateToggle({
	Name = "Ultra Low (No Lag + Low Graphics)",
	CurrentValue = false,
	Flag = "UltraLow",
	Callback = function(on)
		if on then
			BRVS_ApplyUltraLow()
		else
			BRVS_RestoreUltraLow()
		end
	end,
})

BRVS_UtilsTab:CreateSection("AFK")
local ActiveAFKMode = nil
local function StopAFK()
	if BRVS_AntiAfkConn then
		BRVS_AntiAfkConn:Disconnect()
		BRVS_AntiAfkConn = nil
	end
	BRVS_AntiAfkThread = nil
	ActiveAFKMode = nil
end
local function StartAFK_Jump()
	StopAFK()
	ActiveAFKMode = "Jump"
	BRVS_AntiAfkConn = BRVS_Players.LocalPlayer.Idled:Connect(function()
		BRVS_PerformJump(1)
	end)
	BRVS_AntiAfkThread = task.spawn(function()
		while ActiveAFKMode == "Jump" do
			BRVS_PerformJump(1)
			local t = math.random(30, 60)
			local elapsed = 0
			while ActiveAFKMode == "Jump" and elapsed < t do
				task.wait(0.25)
				elapsed = elapsed + 0.25
			end
		end
	end)
end
local VirtualInputManager = game:GetService("VirtualInputManager")
local function StartAFK_Click()
	StopAFK()
	ActiveAFKMode = "Click"
	BRVS_AntiAfkThread = task.spawn(function()
		while ActiveAFKMode == "Click" do
			pcall(function()
				VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
				VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
			end)
			local t = math.random(20, 45)
			local elapsed = 0
			while ActiveAFKMode == "Click" and elapsed < t do
				task.wait(0.25)
				elapsed = elapsed + 0.25
			end
		end
	end)
end
BRVS_UtilsTab:CreateToggle({
	Name = "Anti AFK 1 (Jump)",
	CurrentValue = false,
	Flag = "AntiAFK1",
	Callback = function(on)
		if on then
			StartAFK_Jump()
			BRVS_Rayfield.Flags["AntiAFK2"].Set(false)
		elseif ActiveAFKMode == "Jump" then
			StopAFK()
		end
	end,
})
BRVS_UtilsTab:CreateToggle({
	Name = "Anti AFK 2 (Virtual Click)",
	CurrentValue = false,
	Flag = "AntiAFK2",
	Callback = function(on)
		if on then
			StartAFK_Click()
			BRVS_Rayfield.Flags["AntiAFK1"].Set(false)
		elseif ActiveAFKMode == "Click" then
			StopAFK()
		end
	end,
})

--========================================================
-- Bind island, load config, bind inventories
if BRVS_IslandName then
	BRVS_BindIsland(BRVS_IslandName)
else
	BRVS_Rayfield:Notify({
		Title = "Egg Tools",
		Content = "You are not occupying Island_1..Island_6",
		Duration = 6,
		Image = "alert-triangle",
	})
end

BRVS_Rayfield:LoadConfiguration()
task.defer(function()
	local tries = 0
	while tries < 5 do
		if BRVS_DinoToggle and BRVS_DinoToggle.CurrentValue then
			BRVS_DinoStart() -- will now wait/retry if data isn't ready
			break
		end
		tries = tries + 1
		task.wait(0.5)
	end
end)
BRVS_BindFoodStock()
BRVS_BindInventoryEggs()
BRVS_BindInventoryFood()
BRVS_ApplyUltraLow()
-- Sync state from saved flags
do
	if BRVS_EggDD and BRVS_EggDD.CurrentOption then
		BRVS_SelEggNames = BRVS_EggDD.CurrentOption or {}
	end
	if BRVS_MutDD and BRVS_MutDD.CurrentOption then
		BRVS_SelMutations = BRVS_MutDD.CurrentOption or {}
	end
	if BRVS_FoodDD and BRVS_FoodDD.CurrentOption then
		BRVS_SelectedFood = BRVS_FoodDD.CurrentOption or {}
	end

	if BRVS_AutoBuyToggle and BRVS_AutoBuyToggle.CurrentValue then
		BRVS_AutoBuyEnabled = true
		BRVS_RescanAutoBuy()
	end

	if BRVS_AutoBuyFoodToggle and BRVS_AutoBuyFoodToggle.CurrentValue and not BRVS_FoodBuyThread then
		BRVS_FoodBuyEnabled = true
		BRVS_FoodBuyThread = task.spawn(function()
			while BRVS_FoodBuyEnabled do
				local foods = (BRVS_SelectedFood and #BRVS_SelectedFood > 0) and BRVS_SelectedFood or {}
				local remote = BRVS_GetRemote(BRVS_FOOD_REMOTE_PATH)
				if #foods > 0 and remote and remote:IsA("RemoteEvent") then
					for _, item in ipairs(foods) do
						if not BRVS_FoodBuyEnabled then
							break
						end
						if BRVS_HasFoodStock(item) then
							remote:FireServer(item)
							task.wait(0.05)
						end
					end
				end
				task.wait(BRVS_FoodBuyInterval)
			end
		end)
	end

	if BRVS_PetDelaySlider and BRVS_PetDelaySlider.CurrentValue then
		BRVS_PetCollectInterval = BRVS_PetDelaySlider.CurrentValue
	end
	if BRVS_PetToggle and BRVS_PetToggle.CurrentValue and not BRVS_PetCollectThread then
		BRVS_PetCollectEnabled = true
		BRVS_PetCollectThread = task.spawn(function()
			while BRVS_PetCollectEnabled do
				BRVS_ClaimMyPetsOnce()
				local t = math.max(0.1, BRVS_PetDelaySlider.CurrentValue or BRVS_PetCollectInterval or 3)
				local elapsed = 0
				while BRVS_PetCollectEnabled and elapsed < t do
					task.wait(0.1)
					elapsed = elapsed + 0.1
				end
			end
		end)
	end

	if BRVS_Rayfield.Flags["AntiAFK1"] and BRVS_Rayfield.Flags["AntiAFK1"].CurrentValue then
		StartAFK_Jump()
		BRVS_Rayfield.Flags["AntiAFK2"].Set(false)
	elseif BRVS_Rayfield.Flags["AntiAFK2"] and BRVS_Rayfield.Flags["AntiAFK2"].CurrentValue then
		StartAFK_Click()
		BRVS_Rayfield.Flags["AntiAFK1"].Set(false)
	end
	if BRVS_IslandLabel and BRVS_IslandName then
		BRVS_IslandLabel:Set("Island: " .. BRVS_IslandName)
	end
end
