--========================================================
-- BRVS: Rayfield-powered Tools (Auto Buy, Auto Collect, Inventory, Utils)
--========================================================

--// Services (prefixed)
local BRVS_Players = game:GetService("Players")
local BRVS_ReplicatedStorage = game:GetService("ReplicatedStorage")
local BRVS_Lighting = game:GetService("Lighting")
local BRVS_Workspace = game:GetService("Workspace")

local BRVS_Player = BRVS_Players.LocalPlayer
local BRVS_UserId = BRVS_Player.UserId

--// Fixed lists (prefixed)
local BRVS_EGG_NAMES = {
	"BasicEgg","RareEgg","SuperRareEgg","EpicEgg","LegendEgg",
	"SnowbunnyEgg","PrismaticEgg","HyperEgg","DarkGoatyEgg",
	"VoidEgg","BowserEgg","DemonEgg","RhinoRockEgg","CornEgg",
	"BoneDragonEgg","UltraEgg","DinoEgg","FlyEgg","SaberCubEgg",
	"UnicornEgg","AncientEgg","SeaDragonEgg","UnicornProEgg",
	"GeneralKongEgg","PegasusEgg",
}
local BRVS_MUTATIONS = { "None","Golden","Diamond","Electirc","Fire","Dino","Snow" }

-- Rayfield display lists with explicit "Any"
local BRVS_EGG_OPTIONS = (function() local t={"Any"} for _,v in ipairs(BRVS_EGG_NAMES) do table.insert(t,v) end return t end)()
local BRVS_MUTATION_OPTIONS = (function() local t={"Any"} for _,v in ipairs(BRVS_MUTATIONS) do table.insert(t,v) end return t end)()

-- Food options (multi-select)
local BRVS_FOOD_OPTIONS = {
	"Strawberry","Blueberry","Watermelon","Apple","Orange","Corn","Banana","Grape",
	"Pear","Pineapple","DragonFruit","GoldMango","BloodstoneCycad","ColossalPinecone",
	"VoltGinkgo","DeepseaPearlFruit","Durian",
}

--// World paths
local BRVS_ART_FOLDER = workspace:WaitForChild("Art")
local BRVS_EGGS_FOLDER = BRVS_ReplicatedStorage:WaitForChild("Eggs")

--// Remotes/config
local BRVS_BUYEGG_REMOTE_PATH = { "Remote", "CharacterRE" } -- ReplicatedStorage.Remote.CharacterRE
local BRVS_BUYEGG_ACTION = "BuyEgg"
local BRVS_AUTO_BUY_COOLDOWN = 2 -- seconds per-egg debounce

local BRVS_FOOD_REMOTE_PATH = { "Remote", "FoodStoreRE" } -- ReplicatedStorage.Remote.FoodStoreRE

--========================================================
-- Utils (prefixed)
local function BRVS_GetMyIslandName()
	for i = 1, 6 do
		local island = BRVS_ART_FOLDER:FindFirstChild("Island_" .. i)
		if island and island:GetAttribute("OccupyingPlayerId") == BRVS_UserId then
			return island.Name
		end
	end
	return nil
end

local function BRVS_ContainsOrAny(list, value)
	if not list or #list == 0 then return true end
	for _, v in ipairs(list) do
		if v == "Any" then return true end
		if v == value then return true end
	end
	return false
end

-- NEW: safe remote getter (non-blocking)
local function BRVS_GetRemote(pathArray)
	local node = BRVS_ReplicatedStorage
	for _, name in ipairs(pathArray) do
		node = node and node:FindFirstChild(name)
		if not node then return nil end
	end
	return node
end

--========================================================
-- State (prefixed)
local BRVS_IslandName = BRVS_GetMyIslandName()
local BRVS_IslandFolder = BRVS_IslandName and (BRVS_EGGS_FOLDER:FindFirstChild(BRVS_IslandName) or BRVS_EGGS_FOLDER:WaitForChild(BRVS_IslandName, 10)) or nil
local BRVS_Conns, BRVS_PerEggConns = {}, {}
local function BRVS_ClearConns(t) for _, c in ipairs(t) do pcall(function() c:Disconnect() end) end table.clear(t) end
local function BRVS_ClearPerEggConns() for _, b in pairs(BRVS_PerEggConns) do for _, c in ipairs(b) do pcall(function() c:Disconnect() end) end end BRVS_PerEggConns = {} end

-- User selections (from Rayfield)
local BRVS_SelEggNames = {}   -- {} or includes "Any"
local BRVS_SelMutations = {}  -- {} or includes "Any" / "None"

-- Toggles / misc
local BRVS_AutoBuyEnabled = false
local BRVS_LastFireAt = {} -- [Instance]=time

-- Food auto-buy state
local BRVS_SelectedFood = {} -- multi-select strings
local BRVS_FoodBuyEnabled = false
local BRVS_FoodBuyInterval = 0.2 -- fixed delay (seconds)
local BRVS_FoodBuyThread

-- Anti AFK (jump)
local BRVS_AntiAfkEnabled = false
local BRVS_AntiAfkConn
local BRVS_AntiAfkThread

-- Ultra Low (merged No Lag + Low Graphics)
local BRVS_SavedStates = {}  -- [Instance] = original Enabled (emitters/lights)
local BRVS_Terrain = workspace:FindFirstChildOfClass("Terrain")

-- Auto Collect (new tab)
local BRVS_PetCollectEnabled = false
local BRVS_PetCollectInterval = 3
local BRVS_PetCollectThread

local BRVS_BigPetCollectEnabled = false
local BRVS_BigPetCollectInterval = 5
local BRVS_BigPetCollectThread

--========================================================
-- Anti-AFK (jump) helpers (prefixed)
local function BRVS_GetHumanoid()
	local char = BRVS_Players.LocalPlayer.Character or BRVS_Players.LocalPlayer.CharacterAdded:Wait()
	return char:FindFirstChildOfClass("Humanoid")
end

local function BRVS_PerformJump(times)
	times = times or 1
	local hum = BRVS_GetHumanoid()
	if not hum then return end
	for _ = 1, times do
		hum.Jump = true
		hum:ChangeState(Enum.HumanoidStateType.Jumping)
		task.wait(0.2)
	end
end

--========================================================
-- Ultra Low helpers/state (from Low Graphics) (prefixed)
local BRVS_LG_CONFIG = {
	DisableTextures             = true,
	HideSurfaceAppearance       = false,
	DisableNonPlayerAnimations  = true,
}

local function BRVS_g(inst, prop) local ok,v=pcall(function() return inst[prop] end); return ok and v or nil end
local function BRVS_s(inst, prop, val) pcall(function() inst[prop]=val end) end

local BRVS_lightingProps = {
	"GlobalShadows","EnvironmentSpecularScale","EnvironmentDiffuseScale","Brightness",
	"Ambient","OutdoorAmbient","FogStart","FogEnd","FogColor","ClockTime","ShadowSoftness","Technology"
}
local BRVS_terrainProps  = {
	"Decoration","WaterWaveSize","WaterWaveSpeed","WaterReflectance","WaterTransparency","WaterColor"
}

local BRVS_LG_original = {
	lighting = {}, terrain = {}, postFX = {}, atmo = nil,
	decals = {}, textures = {}, surfaceA = {}
}
for _,p in ipairs(BRVS_lightingProps) do BRVS_LG_original.lighting[p]=BRVS_g(BRVS_Lighting,p) end
for _,fx in ipairs(BRVS_Lighting:GetDescendants()) do
	if fx:IsA("PostEffect") then BRVS_LG_original.postFX[fx]=fx.Enabled end
end
do
	local A = BRVS_Lighting:FindFirstChildOfClass("Atmosphere")
	if A then
		BRVS_LG_original.atmo = { obj=A, props={
			Density=BRVS_g(A,"Density"), Offset=BRVS_g(A,"Offset"), Color=BRVS_g(A,"Color"),
			Decay=BRVS_g(A,"Decay"), Glare=BRVS_g(A,"Glare"), Haze=BRVS_g(A,"Haze"),
			MieScatteringScale=BRVS_g(A,"MieScatteringScale"),
		}}
	end
end
if BRVS_Terrain then for _,p in ipairs(BRVS_terrainProps) do BRVS_LG_original.terrain[p]=BRVS_g(BRVS_Terrain,p) end end

local function BRVS_LG_snapshotVisuals()
	if BRVS_LG_CONFIG.DisableTextures then
		for _,obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("Decal") then if BRVS_LG_original.decals[obj]==nil then BRVS_LG_original.decals[obj]=BRVS_g(obj,"Transparency") end
			elseif obj:IsA("Texture") then if BRVS_LG_original.textures[obj]==nil then BRVS_LG_original.textures[obj]=BRVS_g(obj,"Transparency") end
			end
		end
	end
	if BRVS_LG_CONFIG.HideSurfaceAppearance then
		for _,obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("SurfaceAppearance") and BRVS_LG_original.surfaceA[obj]==nil then
				BRVS_LG_original.surfaceA[obj] = {
					ColorMap=BRVS_g(obj,"ColorMap"), MetalnessMap=BRVS_g(obj,"MetalnessMap"),
					NormalMap=BRVS_g(obj,"NormalMap"), RoughnessMap=BRVS_g(obj,"RoughnessMap")
				}
			end
		end
	end
end
BRVS_LG_snapshotVisuals()

-- Non-player animation blocker
local BRVS_LG_animBlockConns, BRVS_LG_animAddedConn = {}, nil
local function BRVS_LG_isLocalCharacterHumanoid(h) local c=BRVS_Players.LocalPlayer.Character return c and h and h:IsDescendantOf(c) end
local function BRVS_LG_stopAnimator(anim)
	for _,t in ipairs(anim:GetPlayingAnimationTracks()) do pcall(function() t:Stop(0) end) end
	if not BRVS_LG_animBlockConns[anim] then
		BRVS_LG_animBlockConns[anim]=anim.AnimationPlayed:Connect(function(track) pcall(function() track:Stop(0) end) end)
	end
end
local function BRVS_LG_applyAnimationBlock()
	for _,o in ipairs(workspace:GetDescendants()) do
		if o:IsA("Humanoid") then
			if not BRVS_LG_isLocalCharacterHumanoid(o) then local a=o:FindFirstChildOfClass("Animator"); if a then BRVS_LG_stopAnimator(a) end end
		elseif o:IsA("AnimationController") then local a=o:FindFirstChildOfClass("Animator"); if a then BRVS_LG_stopAnimator(a) end end
	end
	if not BRVS_LG_animAddedConn then
		BRVS_LG_animAddedConn = workspace.DescendantAdded:Connect(function(o)
			if o:IsA("Animator") and BRVS_LG_CONFIG.DisableNonPlayerAnimations then
				local h = o.Parent and o.Parent:FindFirstChildOfClass("Humanoid")
				if h and BRVS_LG_isLocalCharacterHumanoid(h) then return end
				BRVS_LG_stopAnimator(o)
			end
		end)
	end
end
local function BRVS_LG_clearAnimationBlock()
	for a,c in pairs(BRVS_LG_animBlockConns) do if c then c:Disconnect() end BRVS_LG_animBlockConns[a]=nil end
	if BRVS_LG_animAddedConn then BRVS_LG_animAddedConn:Disconnect(); BRVS_LG_animAddedConn=nil end
end

local BRVS_LG_active = false
local function BRVS_ApplyLowGraphics()
	BRVS_s(BRVS_Lighting,"GlobalShadows",false)
	BRVS_s(BRVS_Lighting,"EnvironmentSpecularScale",0)
	BRVS_s(BRVS_Lighting,"EnvironmentDiffuseScale",0)
	BRVS_s(BRVS_Lighting,"ShadowSoftness",0)
	for fx in pairs(BRVS_LG_original.postFX) do if fx and fx.Parent then BRVS_s(fx,"Enabled",false) end end
	if BRVS_LG_original.atmo and BRVS_LG_original.atmo.obj then local A=BRVS_LG_original.atmo.obj
		BRVS_s(A,"Density",0); BRVS_s(A,"Glare",0); BRVS_s(A,"Haze",0); BRVS_s(A,"MieScatteringScale",0) end
	if BRVS_Terrain then
        BRVS_s(BRVS_Terrain, "Decoration", false)
        BRVS_s(BRVS_Terrain, "WaterWaveSize", 0)
        BRVS_s(BRVS_Terrain, "WaterWaveSpeed", 0)
        BRVS_s(BRVS_Terrain, "WaterReflectance", 0)
        BRVS_s(BRVS_Terrain, "WaterTransparency", 0)
        BRVS_s(BRVS_Terrain, "WaterColor", Color3.fromRGB(85, 170, 255))
	end
	if BRVS_LG_CONFIG.DisableTextures then
		for o in pairs(BRVS_LG_original.decals)   do if o and o.Parent then BRVS_s(o,"Transparency",1) end end
		for o in pairs(BRVS_LG_original.textures) do if o and o.Parent then BRVS_s(o,"Transparency",1) end end
	end
	if BRVS_LG_CONFIG.HideSurfaceAppearance then
		for o in pairs(BRVS_LG_original.surfaceA) do if o and o.Parent then
			BRVS_s(o,"ColorMap",""); BRVS_s(o,"MetalnessMap",""); BRVS_s(o,"NormalMap",""); BRVS_s(o,"RoughnessMap","") end end
	end
	if BRVS_LG_CONFIG.DisableNonPlayerAnimations then BRVS_LG_applyAnimationBlock() end
	BRVS_LG_active = true
end
local function BRVS_RestoreLowGraphics()
	for p,v in pairs(BRVS_LG_original.lighting) do BRVS_s(BRVS_Lighting,p,v) end
	for fx,was in pairs(BRVS_LG_original.postFX) do if fx and fx.Parent then BRVS_s(fx,"Enabled",was) end end
	if BRVS_LG_original.atmo and BRVS_LG_original.atmo.obj and BRVS_LG_original.atmo.props then
		for p,v in pairs(BRVS_LG_original.atmo.props) do BRVS_s(BRVS_LG_original.atmo.obj,p,v) end
	end
	if BRVS_Terrain then for p,v in pairs(BRVS_LG_original.terrain) do BRVS_s(BRVS_Terrain,p,v) end end
	if BRVS_LG_CONFIG.DisableTextures then
		for o,prev in pairs(BRVS_LG_original.decals)   do if o and o.Parent then BRVS_s(o,"Transparency",prev) end end
		for o,prev in pairs(BRVS_LG_original.textures) do if o and o.Parent then BRVS_s(o,"Transparency",prev) end end
	end
	if BRVS_LG_CONFIG.HideSurfaceAppearance then
		for o,props in pairs(BRVS_LG_original.surfaceA) do if o and o.Parent then for k,v in pairs(props) do BRVS_s(o,k,v) end end end
	end
	BRVS_LG_clearAnimationBlock()
	BRVS_LG_active = false
end

local function BRVS_ApplyUltraLow()
	for _, inst in ipairs(workspace:GetDescendants()) do
		if inst:IsA("ParticleEmitter") or inst:IsA("Trail") or inst:IsA("Beam") or inst:IsA("Highlight")
		or inst:IsA("PointLight") or inst:IsA("SpotLight") or inst:IsA("SurfaceLight") then
			if BRVS_SavedStates[inst] == nil then BRVS_SavedStates[inst] = inst.Enabled end
			inst.Enabled = false
		end
	end
	BRVS_Lighting.GlobalShadows = false
	BRVS_ApplyLowGraphics()
end

local function BRVS_RestoreUltraLow()
	for inst, was in pairs(BRVS_SavedStates) do
		if inst and inst.Parent then
			if inst:IsA("ParticleEmitter") or inst:IsA("Trail") or inst:IsA("Beam") or inst:IsA("Highlight")
			or inst:IsA("PointLight") or inst:IsA("SpotLight") or inst:IsA("SurfaceLight") then
				inst.Enabled = (was == true)
			end
		end
	end
	table.clear(BRVS_SavedStates)
	BRVS_Lighting.GlobalShadows = true
	BRVS_RestoreLowGraphics()
end

--========================================================
-- Core logic (eggs) (prefixed)
local function BRVS_CurrentSelectionsMatch(egg)
	local nameVal = egg:GetAttribute("T") or "(no value)"
	local rawM    = egg:GetAttribute("M")  -- may be nil or ""
	local mutVal  = rawM or "(no value)"

	local nameOk = BRVS_ContainsOrAny(BRVS_SelEggNames, nameVal)

	local mutOk
	if not BRVS_SelMutations or #BRVS_SelMutations == 0 then
		mutOk = true
	else
		mutOk = false
		for _, opt in ipairs(BRVS_SelMutations) do
			if opt == "Any" then mutOk = true break end
			if opt == mutVal then mutOk = true break end
			if opt == "None" and (rawM == nil or rawM == "") then mutOk = true break end
		end
	end

	return nameOk and mutOk
end

local function BRVS_AttemptAutoBuy(egg)
	if not BRVS_AutoBuyEnabled then return end
	if not egg or not egg.Parent or egg.Parent ~= BRVS_IslandFolder then return end
	if not BRVS_CurrentSelectionsMatch(egg) then return end

	local now = os.clock()
	if BRVS_LastFireAt[egg] and (now - BRVS_LastFireAt[egg] < BRVS_AUTO_BUY_COOLDOWN) then return end
	BRVS_LastFireAt[egg] = now

	local args = { BRVS_BUYEGG_ACTION, egg.Name } -- "BuyEgg", "<uid>"
	local remote = BRVS_ReplicatedStorage:WaitForChild(BRVS_BUYEGG_REMOTE_PATH[1]):WaitForChild(BRVS_BUYEGG_REMOTE_PATH[2])
	if remote and remote:IsA("RemoteEvent") then
		remote:FireServer(table.unpack(args))
	else
		warn("BRVS AutoBuy: RemoteEvent missing at ReplicatedStorage." .. table.concat(BRVS_BUYEGG_REMOTE_PATH, "."))
	end
end

local function BRVS_PrintMatches()
	if not BRVS_IslandFolder then return end
	-- print("=== BRVS Matching Eggs ===")
	for _, e in ipairs(BRVS_IslandFolder:GetChildren()) do
		local tVal = e:GetAttribute("T") or "(no value)"
		local mVal = e:GetAttribute("M") or "(no value)"
		if BRVS_CurrentSelectionsMatch(e) then
			-- print(string.format(" - %s | Name: %s | Mutation: %s", e.Name, tVal, mVal))
		end
	end
end

local function BRVS_RescanAutoBuy()
	if not (BRVS_AutoBuyEnabled and BRVS_IslandFolder) then return end
	for _, egg in ipairs(BRVS_IslandFolder:GetChildren()) do
		BRVS_AttemptAutoBuy(egg)
		task.wait()
	end
end

local function BRVS_BindIsland(newName)
	BRVS_ClearConns(BRVS_Conns); BRVS_ClearPerEggConns()
	BRVS_IslandName = newName
	BRVS_IslandFolder = BRVS_IslandName and (BRVS_EGGS_FOLDER:FindFirstChild(BRVS_IslandName) or BRVS_EGGS_FOLDER:WaitForChild(BRVS_IslandName, 10)) or nil
	if not BRVS_IslandFolder then return end

	for _, egg in ipairs(BRVS_IslandFolder:GetChildren()) do
		local c1 = egg:GetAttributeChangedSignal("T"):Connect(function() BRVS_PrintMatches(); BRVS_AttemptAutoBuy(egg) end)
		local c2 = egg:GetAttributeChangedSignal("M"):Connect(function() BRVS_PrintMatches(); BRVS_AttemptAutoBuy(egg) end)
		BRVS_PerEggConns[egg] = { c1, c2 }
		BRVS_AttemptAutoBuy(egg)
	end

	table.insert(BRVS_Conns, BRVS_IslandFolder.ChildAdded:Connect(function(child)
		local c1 = child:GetAttributeChangedSignal("T"):Connect(function() BRVS_PrintMatches(); BRVS_AttemptAutoBuy(child) end)
		local c2 = child:GetAttributeChangedSignal("M"):Connect(function() BRVS_PrintMatches(); BRVS_AttemptAutoBuy(child) end)
		BRVS_PerEggConns[child] = { c1, c2 }
		BRVS_PrintMatches(); BRVS_AttemptAutoBuy(child)
	end))

	table.insert(BRVS_Conns, BRVS_IslandFolder.ChildRemoved:Connect(function(child)
		local b = BRVS_PerEggConns[child]
		if b then for _, c in ipairs(b) do pcall(function() c:Disconnect() end) end end
		BRVS_PerEggConns[child] = nil
		BRVS_PrintMatches()
	end))
end

--========================================================
-- LIVE FOOD STOCK (PlayerGui.Data.FoodStore.LST)
local BRVS_FoodStock      = {}   -- { [FoodName] = number }
local BRVS_FoodStockConns = {}
local BRVS_LST = nil

local function BRVS_DisconnectStock()
	for _, c in ipairs(BRVS_FoodStockConns) do pcall(function() c:Disconnect() end) end
	table.clear(BRVS_FoodStockConns)
end

local function BRVS_SnapshotAttrs(lst)
	table.clear(BRVS_FoodStock)
	for k, v in pairs(lst:GetAttributes()) do
		BRVS_FoodStock[k] = tonumber(v) or 0
	end
	for _, child in ipairs(lst:GetChildren()) do
		if child:IsA("IntValue") or child:IsA("NumberValue") then
			BRVS_FoodStock[child.Name] = tonumber(child.Value) or 0
		end
	end
end

function BRVS_BindFoodStock()
	BRVS_DisconnectStock()

	local pg = BRVS_Player:WaitForChild("PlayerGui")
	local data = pg:WaitForChild("Data")
	local fs = data:WaitForChild("FoodStore")
	local lst = fs:WaitForChild("LST")
	BRVS_LST = lst

	BRVS_SnapshotAttrs(lst)

	table.insert(BRVS_FoodStockConns, lst.AttributeChanged:Connect(function(attr)
		local val = lst:GetAttribute(attr)
		BRVS_FoodStock[attr] = tonumber(val) or 0
	end))

	for _, child in ipairs(lst:GetChildren()) do
		if child:IsA("IntValue") or child:IsA("NumberValue") then
			table.insert(BRVS_FoodStockConns, child:GetPropertyChangedSignal("Value"):Connect(function()
				BRVS_FoodStock[child.Name] = tonumber(child.Value) or 0
			end))
		end
	end

	table.insert(BRVS_FoodStockConns, lst.ChildAdded:Connect(function(child)
		if child:IsA("IntValue") or child:IsA("NumberValue") then
			BRVS_FoodStock[child.Name] = tonumber(child.Value) or 0
			table.insert(BRVS_FoodStockConns, child:GetPropertyChangedSignal("Value"):Connect(function()
				BRVS_FoodStock[child.Name] = tonumber(child.Value) or 0
			end))
		end
	end))

	return BRVS_LST
end

local function BRVS_HasFoodStock(name) return (BRVS_FoodStock[name] or 0) > 0 end

--========================================================
-- INVENTORY: Eggs (PlayerGui.Data.Egg)
local BRVS_InvEggConns = {}
local BRVS_InvEggPerItemConns = {}
local BRVS_InvEggLabel -- set after creating tab

local function BRVS_ClearInvEggConns()
	for _,c in ipairs(BRVS_InvEggConns) do pcall(function() c:Disconnect() end) end
	table.clear(BRVS_InvEggConns)
	for inst, list in pairs(BRVS_InvEggPerItemConns) do
		for _,c in ipairs(list) do pcall(function() c:Disconnect() end) end
		BRVS_InvEggPerItemConns[inst] = nil
	end
end

local function BRVS_HumanEggName(tVal)
	local base = tostring(tVal or "Unknown")
	base = base:gsub("Egg$", "")
	base = (base:sub(1,1):upper() .. base:sub(2):lower())
	return base .. " egg"
end

local function BRVS_RebuildEggInventoryText(eggsFolder)
	if not BRVS_InvEggLabel then return end
	if not eggsFolder then
		BRVS_InvEggLabel:Set("Egg:\n- (none)")
		return
	end

	local counts = {}  -- key: T .. "\0" .. (M or "")
	for _, egg in ipairs(eggsFolder:GetChildren()) do
		-- Skip eggs marked with D
		if not egg:GetAttribute("D") then
			local T = egg:GetAttribute("T")
			local M = egg:GetAttribute("M")
			local key = tostring(T or "Unknown") .. "\0" .. tostring(M or "")
			counts[key] = (counts[key] or 0) + 1
		end
	end

	local lines = {}
	for key, n in pairs(counts) do
		local T, M = key:match("^(.-)\0(.*)$")
		local name = BRVS_HumanEggName(T)
		local line = (M and M ~= "") and string.format("- %s | %s (%d)", name, M, n) or string.format("- %s (%d)", name, n)
		table.insert(lines, line)
	end
	table.sort(lines, function(a,b) return a:lower()<b:lower() end)

	local text = "Egg:"
	if #lines == 0 then
		text = text .. "\n- (none)"
	else
		for _,ln in ipairs(lines) do text = text .. "\n" .. ln end
	end
	BRVS_InvEggLabel:Set(text)
end

local function BRVS_BindInventoryEggs()
	BRVS_ClearInvEggConns()

	local pg = BRVS_Player:WaitForChild("PlayerGui")
	local data = pg:WaitForChild("Data")
	local eggs = data:WaitForChild("Egg")  -- array of uid nodes with attributes T and optional M

	BRVS_RebuildEggInventoryText(eggs)

	table.insert(BRVS_InvEggConns, eggs.ChildAdded:Connect(function(child)
		local list = {}
		table.insert(list, child:GetAttributeChangedSignal("T"):Connect(function() BRVS_RebuildEggInventoryText(eggs) end))
		table.insert(list, child:GetAttributeChangedSignal("M"):Connect(function() BRVS_RebuildEggInventoryText(eggs) end))
		table.insert(list, child:GetAttributeChangedSignal("D"):Connect(function() BRVS_RebuildEggInventoryText(eggs) end))
		BRVS_InvEggPerItemConns[child] = list
		BRVS_RebuildEggInventoryText(eggs)
	end))
	table.insert(BRVS_InvEggConns, eggs.ChildRemoved:Connect(function(child)
		local list = BRVS_InvEggPerItemConns[child]
		if list then for _,c in ipairs(list) do pcall(function() c:Disconnect() end) end end
		BRVS_InvEggPerItemConns[child] = nil
		BRVS_RebuildEggInventoryText(eggs)
	end))

	for _, child in ipairs(eggs:GetChildren()) do
		local list = {}
		table.insert(list, child:GetAttributeChangedSignal("T"):Connect(function() BRVS_RebuildEggInventoryText(eggs) end))
		table.insert(list, child:GetAttributeChangedSignal("M"):Connect(function() BRVS_RebuildEggInventoryText(eggs) end))
		table.insert(list, child:GetAttributeChangedSignal("D"):Connect(function() BRVS_RebuildEggInventoryText(eggs) end))
		BRVS_InvEggPerItemConns[child] = list
	end
end

--========================================================
-- Rayfield UI (prefixed locals)
local BRVS_Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local BRVS_Window = BRVS_Rayfield:CreateWindow({
	Name = "Build A Zoo (SNOW) | HrafnHub",
	Icon = "egg",
	LoadingTitle = "Loading y0ur stuff",
	LoadingSubtitle = "by HrafnHub",
	ShowText = "UI HrafnHub",
	Theme = "Dark Blue",
	ToggleUIKeybind = "K",
	DisableRayfieldPrompts = true,
	DisableBuildWarnings = true,
	ConfigurationSaving = {
		Enabled = true,
		FolderName = "EggTools",
		FileName = "EggTools_Config"
	},
	Discord = { Enabled = false },
	KeySystem = false,
})

task.spawn(function()
	while true do
		task.wait(math.random(180, 600))
		RayfieldLibrary:Notify({
			Title = "Build A Zoo (SNOW) | HrafnHub",
			Content = "Enjoying this ? Support me at discord.gg/HrafnHub",
			Duration = 7,
			Image = 5013032530,
		})
	end
end)

-- =================== TAB: Auto Buy ===================
local BRVS_AutoTab = BRVS_Window:CreateTab("Auto Buy", "shopping-bag")
local BRVS_IslandLabel = BRVS_AutoTab:CreateLabel(BRVS_IslandName and ("Island: "..BRVS_IslandName) or "Island: (none)")

BRVS_AutoTab:CreateSection("Filters")
local BRVS_EggDD = BRVS_AutoTab:CreateDropdown({
	Name = "Name(s)",
	Options = BRVS_EGG_OPTIONS,
	CurrentOption = {},
	MultipleOptions = true,
	Flag = "EggNames",
	Callback = function(options)
		BRVS_SelEggNames = options or {}
		BRVS_PrintMatches()
		BRVS_RescanAutoBuy()
	end,
})
local BRVS_MutDD = BRVS_AutoTab:CreateDropdown({
	Name = "Mutation(s)",
	Options = BRVS_MUTATION_OPTIONS,
	CurrentOption = {},
	MultipleOptions = true,
	Flag = "Mutations",
	Callback = function(options)
		BRVS_SelMutations = options or {}
		BRVS_PrintMatches()
		BRVS_RescanAutoBuy()
	end,
})

BRVS_AutoTab:CreateSection("Automation")
local BRVS_AutoBuyToggle = BRVS_AutoTab:CreateToggle({
	Name = "Auto Buy Eggs",
	CurrentValue = false,
	Flag = "AutoBuy",
	Callback = function(on)
		BRVS_AutoBuyEnabled = on
		if BRVS_AutoBuyEnabled then
			BRVS_RescanAutoBuy()
			BRVS_Rayfield:Notify({ Title = "Auto Buy", Content = "Enabled", Duration = 4, Image = "shopping-bag" })
		else
			BRVS_Rayfield:Notify({ Title = "Auto Buy", Content = "Disabled", Duration = 3, Image = "ban" })
		end
	end,
})

BRVS_AutoTab:CreateSection("Food Store")
-- Food multi-select
local BRVS_FoodDD = BRVS_AutoTab:CreateDropdown({
	Name = "Food (multi-select)",
	Options = BRVS_FOOD_OPTIONS,
	CurrentOption = {},
	MultipleOptions = true,
	Flag = "FoodSelect",
	Callback = function(options)
		BRVS_SelectedFood = options or {}
	end,
})

-- Auto Buy Food toggle (uses LIVE STOCK, fixed 0.2s tick)
local BRVS_AutoBuyFoodToggle = BRVS_AutoTab:CreateToggle({
	Name = "Auto Buy Food",
	CurrentValue = false,
	Flag = "AutoBuyFood",
	Callback = function(on)
		BRVS_FoodBuyEnabled = on
		BRVS_FoodBuyThread = nil
		if not BRVS_FoodBuyEnabled then
			BRVS_Rayfield:Notify({ Title = "Food Store", Content = "Auto Buy Food: OFF", Duration = 2.5, Image = "ban" })
			return
		end
		BRVS_FoodBuyThread = task.spawn(function()
			BRVS_Rayfield:Notify({ Title = "Food Store", Content = "Auto Buy Food: ON", Duration = 2.5, Image = "shopping-cart" })
			while BRVS_FoodBuyEnabled do
				local foods = (BRVS_SelectedFood and #BRVS_SelectedFood > 0) and BRVS_SelectedFood or {}
				local remote = BRVS_GetRemote(BRVS_FOOD_REMOTE_PATH)
				if #foods > 0 and remote and remote:IsA("RemoteEvent") then
					for _, item in ipairs(foods) do
						if not BRVS_FoodBuyEnabled then break end
						if BRVS_HasFoodStock(item) then
							remote:FireServer(item)
							task.wait(0.05)
						end
					end
				end
				task.wait(BRVS_FoodBuyInterval) -- fixed 0.2s tick
			end
		end)
	end,
})

-- =================== TAB: Auto Collect ===================
local BRVS_CollectTab = BRVS_Window:CreateTab("Auto Collect", "package")

BRVS_CollectTab:CreateSection("Auto Collect Pet")
local BRVS_PetDelaySlider = BRVS_CollectTab:CreateSlider({
	Name = "Pet Delay",
	Range = {1, 60},
	Increment = 1,
	Suffix = "sec",
	CurrentValue = BRVS_PetCollectInterval,
	Flag = "PetCollectDelay",
	Callback = function(val)
		BRVS_PetCollectInterval = tonumber(val) or BRVS_PetCollectInterval
	end,
})

-- Pet claimer using PlayerGui.Data.Pets → UIDs
-- Optimized, rate-limited pet claimer (safe for your own pets)
local function BRVS_ClaimMyPetsOnce(ratePerSec)
	ratePerSec = math.max(1, tonumber(ratePerSec) or 15) -- default: 15 claims/sec
	local interval = 1 / ratePerSec

	-- === Step 0: Find required nodes ===
	local pg = BRVS_Player:FindFirstChildOfClass("PlayerGui"); if not pg then return end
	local data = pg:FindFirstChild("Data"); if not data then return end
	local petsNode = data:FindFirstChild("Pets"); if not petsNode then return end
	local workspacePets = BRVS_Workspace:FindFirstChild("Pets"); if not workspacePets then return end

	-- === Step 1: Collect owned pet UIDs (deduped) ===
	local owned = {}
	for _, obj in ipairs(petsNode:GetChildren()) do
		local uid = (obj:IsA("StringValue") and obj.Value ~= "" and obj.Value) or obj.Name
		if type(uid) == "string" and uid ~= "" then
			owned[uid] = true
		end
	end
	if not next(owned) then return end

	-- === Step 2: Index workspace pets (UID → RemoteEvent) ===
	local reByUID = {}
	for _, model in ipairs(workspacePets:GetChildren()) do
		if model:IsA("Model") then
			local root = model:FindFirstChild("RootPart")
			local re = root and root:FindFirstChild("RE")
			if re and re.FireServer then
				reByUID[model.Name] = re
			end
		end
	end

	-- === Helper: Rate-limited RemoteEvent firing ===
	local function firePaced(queue)
		local nextTime = os.clock()
		for i = 1, #queue do
			local re = queue[i]
			if re and re.FireServer then
				local now = os.clock()
				if now < nextTime then
					task.wait(nextTime - now)
				end
				re:FireServer("Claim")
				nextTime = nextTime + interval
			end
		end
	end

	-- === Step 3: Claim pets that exist now ===
	local queue = {}
	for uid in pairs(owned) do
		local re = reByUID[uid]
		if re then
			queue[#queue+1] = re
		end
	end
	if #queue > 0 then
		firePaced(queue)
	end

	-- === Step 4: Short retry window for late-loaded pets ===
	local missing = {}
	for uid in pairs(owned) do
		if not reByUID[uid] then
			missing[#missing+1] = uid
		end
	end
	if #missing > 0 then
		task.wait(0.2) -- wait 200ms for late replication
		local retryQueue = {}
		for _, uid in ipairs(missing) do
			local model = workspacePets:FindFirstChild(uid)
			if model and model:IsA("Model") then
				local root = model:FindFirstChild("RootPart")
				local re = root and root:FindFirstChild("RE")
				if re and re.FireServer then
					retryQueue[#retryQueue+1] = re
				end
			end
		end
		if #retryQueue > 0 then
			firePaced(retryQueue)
		end
	end
end


local BRVS_PetToggle = BRVS_CollectTab:CreateToggle({
	Name = "Auto Collect Pet",
	CurrentValue = false,
	Flag = "PetCollectToggle",
	Callback = function(on)
		BRVS_PetCollectEnabled = on
		BRVS_PetCollectThread = nil
		if not BRVS_PetCollectEnabled then return end
		BRVS_PetCollectThread = task.spawn(function()
			while BRVS_PetCollectEnabled do
				BRVS_ClaimMyPetsOnce()
				local t = math.max(0.1, BRVS_PetDelaySlider.CurrentValue or BRVS_PetCollectInterval or 3)
				local elapsed = 0
				while BRVS_PetCollectEnabled and elapsed < t do
					task.wait(0.1); elapsed = elapsed + 0.1
				end
			end
		end)
	end,
})

-- =================== TAB: Auto Hatch ===================
local BRVS_HatchTab = BRVS_Window:CreateTab("Auto Hatch", "egg")
BRVS_HatchTab:CreateSection("Auto Hatch (on mark)")

-- config/state
local BRVS_HatchEnabled = false
local BRVS_HatchThread = nil
local BRVS_HatchRate = 15 -- fixed rate (~15/sec safe)
local BRVS_HatchLabel = nil

-- ===== Non-yielding helpers (use BRVS_* globals) =====
local function LooksLikeEgg(m)
	return m and m:IsA("Model")
		and m:GetAttribute("UserId") ~= nil
		and (m:FindFirstChild("RootPart", true) ~= nil)
end

local function OwnedByLocal(m)
	return m:GetAttribute("UserId") == BRVS_UserId
end

local function HasMark(m)
	return m:FindFirstChild("ExclamationMark", true) ~= nil
end

local function GetRF(m)
	local rf = m:FindFirstChild("RF")
	if rf and rf:IsA("RemoteFunction") then return rf end
	rf = m:FindFirstChild("RF", true)
	if rf and rf:IsA("RemoteFunction") then return rf end
	return nil
end

-- ===== Queue-based worker (paced) =====
-- local PLAYER_BLOCKS = BRVS_Workspace:FindFirstChild("PlayerBuiltBlocks")

-- local function BRVS_StartHatchWorker()
-- 	if not PLAYER_BLOCKS then return end

-- 	local queue = {}
-- 	local inQueue = setmetatable({}, { __mode = "k" })
-- 	local tried   = setmetatable({}, { __mode = "k" })
-- 	local retryAt = setmetatable({}, { __mode = "k" })
-- 	local hatchedCount = 0

-- 	local function Enqueue(egg)
-- 		if not egg or inQueue[egg] or tried[egg] then return end
-- 		if not LooksLikeEgg(egg) or not OwnedByLocal(egg) or not HasMark(egg) then return end
-- 		if not GetRF(egg) then return end
-- 		queue[#queue + 1] = egg
-- 		inQueue[egg] = true
-- 	end

-- 	-- Label updater
-- 	task.spawn(function()
-- 		while BRVS_HatchEnabled do
-- 			local text = string.format(
-- 				"Status: %s | Queue: %d | Hatched: %d",
-- 				(#queue > 0 and "Running" or "Idle"),
-- 				#queue,
-- 				hatchedCount
-- 			)
-- 			if BRVS_HatchLabel then BRVS_HatchLabel:Set(text) end
-- 			task.wait(1)
-- 		end
-- 		if BRVS_HatchLabel then BRVS_HatchLabel:Set("Status: Disabled") end
-- 	end)

-- 	-- Seed with existing marked eggs
-- 	for _, inst in ipairs(PLAYER_BLOCKS:GetDescendants()) do
-- 		if inst:IsA("Model") and LooksLikeEgg(inst) and OwnedByLocal(inst) and HasMark(inst) then
-- 			Enqueue(inst)
-- 		end
-- 	end

-- 	-- Watch for new eggs and marks
-- 	local conA = PLAYER_BLOCKS.DescendantAdded:Connect(function(inst)
-- 		if not BRVS_HatchEnabled then return end
-- 		if inst:IsA("Model") then
-- 			if LooksLikeEgg(inst) and OwnedByLocal(inst) and HasMark(inst) then
-- 				Enqueue(inst)
-- 			end
-- 			inst.DescendantAdded:Connect(function(d)
-- 				if not BRVS_HatchEnabled then return end
-- 				if d.Name == "ExclamationMark" then
-- 					local egg = d:FindFirstAncestorOfClass("Model")
-- 					if egg then Enqueue(egg) end
-- 				end
-- 			end)
-- 		elseif inst.Name == "ExclamationMark" then
-- 			local egg = inst:FindFirstAncestorOfClass("Model")
-- 			if egg then Enqueue(egg) end
-- 		end
-- 	end)

-- 	-- Paced worker loop
-- 	BRVS_HatchThread = task.spawn(function()
-- 		local nextTime = os.clock()
-- 		local interval = 1 / BRVS_HatchRate
-- 		while BRVS_HatchEnabled do
-- 			-- schedule due retries
-- 			for egg, t in pairs(retryAt) do
-- 				if not inQueue[egg] and egg.Parent and os.clock() >= t
-- 					and LooksLikeEgg(egg) and OwnedByLocal(egg) and HasMark(egg) then
-- 					Enqueue(egg)
-- 					retryAt[egg] = nil
-- 				elseif not egg.Parent then
-- 					retryAt[egg] = nil
-- 				end
-- 			end

-- 			local egg = table.remove(queue, 1)
-- 			if egg then
-- 				inQueue[egg] = nil

-- 				local now = os.clock()
-- 				if now < nextTime then
-- 					task.wait(nextTime - now)
-- 				end
-- 				nextTime = os.clock() + interval

-- 				if egg.Parent and LooksLikeEgg(egg) and OwnedByLocal(egg) and HasMark(egg) then
-- 					local rf = GetRF(egg)
-- 					if rf then
-- 						local ok, success = pcall(function()
-- 							return rf:InvokeServer("Hatch")
-- 						end)
-- 						if ok and success == true then
-- 							tried[egg] = true
-- 							hatchedCount = hatchedCount + 1
-- 						else
-- 							if not tried[egg] and retryAt[egg] == nil then
-- 								retryAt[egg] = os.clock() + 2
-- 							end
-- 						end
-- 					end
-- 				end
-- 			else
-- 				task.wait(0.1)
-- 			end
-- 		end
-- 		if conA then conA:Disconnect() end
-- 	end)
-- end

-- local function BRVS_StopHatchWorker()
-- 	BRVS_HatchEnabled = false
-- end
-- ===== Immediate hatch worker (no queue / no rate limit) =====
local PLAYER_BLOCKS = BRVS_Workspace:FindFirstChild("PlayerBuiltBlocks")

-- connections we manage so Stop can cleanly disconnect
local BRVS_HatchConns = {}
local function _clearHatchConns()
	for _, c in ipairs(BRVS_HatchConns) do
		pcall(function() c:Disconnect() end)
	end
	BRVS_HatchConns = {}
end

local function BRVS_StartHatchWorker()
	if not PLAYER_BLOCKS then return end

	local hatchedCount = 0
	local inFlight = setmetatable({}, { __mode = "k" }) -- debounce per egg
	local finished = setmetatable({}, { __mode = "k" }) -- optional: mark done

	-- label updater (no queue now)
	task.spawn(function()
		while BRVS_HatchEnabled do
			local text = string.format("Status: %s | Hatched: %d",
				"Running", hatchedCount)
			if BRVS_HatchLabel then BRVS_HatchLabel:Set(text) end
			task.wait(1)
		end
		if BRVS_HatchLabel then BRVS_HatchLabel:Set("Status: Disabled") end
	end)

	local function HatchOnce(egg)
		if not BRVS_HatchEnabled then return end
		if not egg or not egg.Parent then return end
		if inFlight[egg] or finished[egg] then return end
		if not (LooksLikeEgg(egg) and OwnedByLocal(egg) and HasMark(egg)) then return end

		local rf = GetRF(egg)
		if not rf then return end

		inFlight[egg] = true
		task.spawn(function()
			local ok, success = pcall(function()
				return rf:InvokeServer("Hatch")
			end)
			if ok and success == true then
				finished[egg] = true
				hatchedCount += 1
			end
			inFlight[egg] = nil
		end)
	end

	-- Seed: scan existing marked eggs and hatch immediately
	for _, inst in ipairs(PLAYER_BLOCKS:GetDescendants()) do
		if inst:IsA("Model") and LooksLikeEgg(inst) and OwnedByLocal(inst) and HasMark(inst) then
			HatchOnce(inst)
		end
	end

	-- Helper: when a model is added, also watch for its mark appearing
	local function hookModel(m)
		if not m or not m:IsA("Model") then return end
		-- If it already has a mark, hatch now
		if LooksLikeEgg(m) and OwnedByLocal(m) and HasMark(m) then
			HatchOnce(m)
		end
		-- Watch for ExclamationMark under this model only
		local con = m.DescendantAdded:Connect(function(d)
			if not BRVS_HatchEnabled then return end
			if d.Name == "ExclamationMark" then
				local egg = d:FindFirstAncestorOfClass("Model")
				if egg then HatchOnce(egg) end
			end
		end)
		table.insert(BRVS_HatchConns, con)
	end

	-- Global watch: any new model or mark under PLAYER_BLOCKS
	table.insert(BRVS_HatchConns, PLAYER_BLOCKS.DescendantAdded:Connect(function(inst)
		if not BRVS_HatchEnabled then return end
		if inst:IsA("Model") then
			-- A new egg candidate appeared
			hookModel(inst)
		elseif inst.Name == "ExclamationMark" then
			-- A mark appeared anywhere under PLAYER_BLOCKS
			local egg = inst:FindFirstAncestorOfClass("Model")
			if egg then HatchOnce(egg) end
		end
	end))
end

local function BRVS_StopHatchWorker()
	BRVS_HatchEnabled = false
	_clearHatchConns()
	-- Label will be set to Disabled by the updater thread on next tick,
	-- but ensure immediate UI feedback:
	if BRVS_HatchLabel then BRVS_HatchLabel:Set("Status: Disabled") end
end


-- UI: toggle + status label (label is created directly under the toggle)
local BRVS_HatchToggle = BRVS_HatchTab:CreateToggle({
	Name = "Auto Hatch (on mark)",
	CurrentValue = false,
	Flag = "AutoHatchOnMark",
	Callback = function(on)
		if on then
			if BRVS_HatchEnabled then return end
			BRVS_HatchEnabled = true
			BRVS_StartHatchWorker()
		else
			BRVS_StopHatchWorker()
		end
	end,
})

BRVS_HatchLabel = BRVS_HatchTab:CreateLabel("Status: Disabled")

-- =================== TAB: Auto Fish ===================
local BRVS_FishTab = BRVS_Window:CreateTab("Auto Fish", "fish")

local RS = game:GetService("ReplicatedStorage")
local YELLOW_WEATHER = Color3.fromRGB(255, 248, 67)

local BRVS_FishEnabled = false
local BRVS_LastMarkerKey = nil
local BRVS_FishThread

-- === config ===
local BRVS_FishBait = "FishingBait3"       -- default bait
local BRVS_CastForward = 3                 -- studs forward
local BRVS_WaterHeight = 11                -- Y height of water plane
local BRVS_TeleportYOffset = 5             -- lift after teleport
local BRVS_PollInterval = 0.5              -- check interval

-- remotes
local CharacterRE = RS:WaitForChild("Remote"):WaitForChild("CharacterRE")
local FishingRE   = RS:WaitForChild("Remote"):WaitForChild("FishingRE")
local ResourceRE  = RS:WaitForChild("Remote"):WaitForChild("ResourceRE")

-- helper for vector.create compatibility
local function MakeVec3(x,y,z)
    local ok, v = pcall(function()
        return (vector and typeof(vector) == "table" and vector.create) and vector.create(x,y,z) or nil
    end)
    return v or Vector3.new(x,y,z)
end

-- ----- Weather label helpers -----
local function BRVS_GetWeatherLabel()
    local gui = BRVS_Player:FindFirstChild("PlayerGui"); if not gui then return nil end
    local overlay = gui:FindFirstChild("Overlay"); if not overlay then return nil end
    local weather = overlay:FindFirstChild("Weather"); if not weather then return nil end
    local btn = weather:FindFirstChild("Btn"); if not btn then return nil end
    return btn:FindFirstChild("TimeLabel")
end

local function BRVS_GetMarkerKey(lbl)
    if not lbl then return "nil" end
    local ok, c = pcall(function() return lbl.TextColor3 end)
    if ok and typeof(c) == "Color3" then
        return string.format("%d,%d,%d", math.floor(c.R*255), math.floor(c.G*255), math.floor(c.B*255))
    end
    local attr = lbl:GetAttribute("Color3")
    if typeof(attr) == "Color3" then
        return string.format("%d,%d,%d", math.floor(attr.R*255), math.floor(attr.G*255), math.floor(attr.B*255))
    end
    return "unknown"
end

local function BRVS_IsMarkerYellow(lbl)
    if not lbl then return false end
    local ok, c = pcall(function() return lbl.TextColor3 end)
    if ok and typeof(c) == "Color3" then return c == YELLOW_WEATHER end
    local attr = lbl:GetAttribute("Color3")
    return (typeof(attr) == "Color3" and attr == YELLOW_WEATHER)
end

-- ----- Predefined FishingSpotsN (1..8) -----
local FishingSpots = {
    [1] = CFrame.new(-290.975464, 16.8169041, -184.160797, 0.108745351, -5.46932588e-09, -0.994069636, 8.62232881e-08, 1, 3.93036403e-09, 0.994069636, -8.61393588e-08, 0.108745351),
    [2] = CFrame.new(-195.223938, 16.7869015, 391.185425, 0.113660276, -2.27553336e-08, 0.993519664, -2.0718856e-08, 1, 2.52740282e-08, -0.993519664, -2.34572433e-08, 0.113660276),
    [3] = CFrame.new(75.640007, 16.8738537, 393.076874, 0.0410775058, -1.99907255e-08, 0.999155939, 4.38611458e-08, 1, 1.82043856e-08, -0.999155939, 4.30763372e-08, 0.0410775058),
    [4] = CFrame.new(74.813736, 16.5027637, -187.207809, 0.07510674, 1.39998342e-08, 0.997175515, -6.37320738e-08, 1, -9.23922272e-09, -0.997175515, -6.28581347e-08, 0.07510674),
    [5] = CFrame.new(-462.940796, 19.4740677, -162.363861, 0.0573989227, -1.1758312e-07, 0.998351336, -4.44201156e-08, 1, 1.2033118e-07, -0.998351336, -5.12537639e-08, 0.0573989227),
    [6] = CFrame.new(-461.377563, 16.8520432, 392.929688, -0.248992831, 4.39117986e-09, 0.968505323, -3.68257105e-08, 1, -1.40014906e-08, -0.968505323, -3.9152166e-08, -0.248992831),
    [7] = CFrame.new(246.968002, 19.6071167, 373.15921, -0.601966798, 4.40889414e-09, -0.798521101, 1.82688993e-08, 1, -8.25072366e-09, 0.798521101, -1.95547631e-08, -0.601966798),
    [8] = CFrame.new(240.256897, 15.2399073, -174.516937, -0.0908729136, -1.02172869e-07, -0.995862484, 3.76559512e-08, 1, -1.0603349e-07, 0.995862484, -4.71357211e-08, -0.0908729136),
}

-- ----- Compute cast pos from a spot CF -----
local function GetCastPos(baseCF)
    local forward = baseCF.LookVector * BRVS_CastForward
    local castPos = baseCF.Position + forward
    castPos = Vector3.new(castPos.X, BRVS_WaterHeight, castPos.Z) -- force Y = water level
    return MakeVec3(castPos.X, castPos.Y, castPos.Z)
end

-- ----- Teleport & cast helpers -----
local function BRVS_TeleportTo(cf)
    local char = BRVS_Player.Character or BRVS_Player.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart", 5)
    if not hrp then return false end
    hrp.CFrame = cf + Vector3.new(0, BRVS_TeleportYOffset, 0)
    return true
end

local function BRVS_SendFocus()
    CharacterRE:FireServer("Focus", "FishRob")
end

local function BRVS_SendThrow(targetCF)
    local pos = GetCastPos(targetCF)
    FishingRE:FireServer("Throw", { Bait = BRVS_FishBait, Pos = pos })
end
-- state
local isFishing = false
local pendingMarkerChange = false

local function BRVS_DoFishingSequence(cf)
    if isFishing then return end
    isFishing = true
	for _=1, 4 do
        task.wait(0.1)
		BRVS_SendFocus()
    end
    task.wait(0.2)
    BRVS_SendThrow(cf)

    -- pull + pout cycle
    task.wait(0.3)
    ResourceRE:FireServer("PULL", "FX/FX_Fish")

    for _=1, 10 do
        task.wait(0.2)
        FishingRE:FireServer("POUT", { SUC = 1 })
    end

    isFishing = false

    -- if marker changed during fishing → allow restart
    if pendingMarkerChange then
        pendingMarkerChange = false
        BRVS_LastMarkerKey = nil -- force re-detect in loop
    end
end

-- ----- Pick the current FishPointN, then map to FishingSpotsN -----
local function BRVS_FindActiveFishPointIndices()
    -- returns an array of N numbers for FishPointN that currently have FX_Fish_Special
    local result = {}
    local FishPoints = workspace:FindFirstChild("FishPoints")
    if not FishPoints then return result end

    for _, fp in ipairs(FishPoints:GetChildren()) do
        if fp:FindFirstChild("FX_Fish_Special", true) then
            local name = fp.Name or ""
            local n = tonumber(string.match(name, "FishPoint(%d+)"))
            if n then table.insert(result, n) end
        end
    end
    return result
end

local function BRVS_PickSpotByCurrentFishPoint()
    local indices = BRVS_FindActiveFishPointIndices()
    if #indices == 0 then return nil end
    local n = indices[math.random(1, #indices)]
    local cf = FishingSpots[n]
    return cf
end

-- Main Fish Loop

local function BRVS_StartAutoFish()
    if BRVS_FishThread then return end
    BRVS_FishThread = task.spawn(function()
        local lbl = BRVS_GetWeatherLabel()
        BRVS_LastMarkerKey = nil

        while BRVS_FishEnabled do
            if lbl and not BRVS_IsMarkerYellow(lbl) then
                local key = BRVS_GetMarkerKey(lbl)

                if key ~= BRVS_LastMarkerKey then
                    if isFishing then
                        -- don’t interrupt, just flag it
                        pendingMarkerChange = true
                    else
                        BRVS_LastMarkerKey = key
                        BRVS_Rayfield:Notify({
                            Title = "Auto Fish",
                            Content = "New marker detected, fishing started",
                            Duration = 0.5,
                            Image = "fish"
                        })
                    end
                end

                -- loop while marker unchanged
                while BRVS_FishEnabled and BRVS_GetMarkerKey(lbl) == BRVS_LastMarkerKey and not BRVS_IsMarkerYellow(lbl) do
                    if not isFishing then
                        local cf = BRVS_PickSpotByCurrentFishPoint()
                        if cf and BRVS_TeleportTo(cf) then
                            task.wait(0.2)
                            BRVS_DoFishingSequence(cf)
                        end
                        task.wait(1.1)
                    else
                        task.wait(0.25) -- wait for current fishing to finish
                    end
                end
            else
                -- marker is yellow
                task.wait(BRVS_PollInterval)
            end
        end
        BRVS_FishThread = nil
    end)
end



-- === UI: bait selector + toggle ===
BRVS_FishTab:CreateDropdown({
    Name = "Select Bait",
    Options = {
        "Cheese Bait (300) | FishingBait1",
        "Fly Bait (10m) | FishingBait2",
        "Fish Bait (800m) | FishingBait3"
    },
    CurrentOption = "Fish Bait (800m) | FishingBait3",
    Flag = "FishBait",
    Callback = function(option)
    local selected = option
    if type(option) == "table" then
        selected = option[1]  -- take first choice if table
    end

    if string.find(selected, "FishingBait1") then
        BRVS_FishBait = "FishingBait1"
    elseif string.find(selected, "FishingBait2") then
        BRVS_FishBait = "FishingBait2"
    elseif string.find(selected, "FishingBait3") then
        BRVS_FishBait = "FishingBait3"
    end

    BRVS_Rayfield:Notify({
        Title = "Bait Selected",
        Content = BRVS_FishBait,
        Duration = 0.5,
        Image = "check"
    })
end,
})

BRVS_FishTab:CreateToggle({
    Name = "Auto Fish (auto teleport to spot event)",
    CurrentValue = false,
    Flag = "AutoFish",
    Callback = function(on)
        BRVS_FishEnabled = on
        if on then
            BRVS_StartAutoFish()
            BRVS_Rayfield:Notify({ Title = "Auto Fish", Content = "Enabled", Duration = 0.5, Image = "fish" })
        else
            BRVS_LastMarkerKey = nil
            BRVS_Rayfield:Notify({ Title = "Auto Fish", Content = "Disabled", Duration = 0.5, Image = "ban" })
        end
    end,
})

-- =================== TAB: Inventory (Paragraph-based) ===================
local BRVS_InvTab = BRVS_Window:CreateTab("Inventory", "box")

-- Paragraph element for Food (placed before Eggs)
local BRVS_InvFoodPara = BRVS_InvTab:CreateParagraph({
    Title = "Food",
    Content = "loading..."
})

-- Connections we manage for Food paragraph updates
local BRVS_InvFoodConns = {}
local function BRVS_ClearInvFoodConns()
    for _, c in ipairs(BRVS_InvFoodConns) do pcall(function() c:Disconnect() end) end
    BRVS_InvFoodConns = {}
end

local function BRVS_RebuildFoodText(assetInst)
    if not BRVS_InvFoodPara then return end
    if not assetInst then
        BRVS_InvFoodPara:Set({ Title = "Food", Content = "(none)" })
        return
    end

    local lines = {}
    for _, name in ipairs(BRVS_FOOD_OPTIONS) do
        local v = assetInst:GetAttribute(name)
        if v ~= nil and v ~= false and v ~= 0 then
            -- If numeric and >0, show a count; otherwise just show the name
            if type(v) == "number" then
                if v > 0 then
                    table.insert(lines, string.format("• %s  ×%d", name, v))
                end
            else
                table.insert(lines, string.format("• %s", name))
            end
        end
    end

    table.sort(lines, function(a, b) return a:lower() < b:lower() end)
    BRVS_InvFoodPara:Set({
        Title = "Food",
        Content = (#lines == 0) and "(none)" or table.concat(lines, "\n")
    })
end

local function BRVS_BindInventoryFood()
    BRVS_ClearInvFoodConns()

    -- Resolve Players.LocalPlayer.PlayerGui.Data.Asset
    local pg = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
    local data = pg:WaitForChild("Data")
    local asset = data:WaitForChild("Asset") -- attributes live here

    -- Initial render
    BRVS_RebuildFoodText(asset)

    -- Listen for changes on each food attribute we care about
    for _, name in ipairs(BRVS_FOOD_OPTIONS) do
        table.insert(BRVS_InvFoodConns, asset:GetAttributeChangedSignal(name):Connect(function()
            BRVS_RebuildFoodText(asset)
        end))
    end

    -- Optional: if the Asset instance could be swapped out at runtime, rebind on replacement
    -- (Uncomment if needed in your game)
    -- table.insert(BRVS_InvFoodConns, data.ChildAdded:Connect(function(child)
    --     if child.Name == "Asset" then BRVS_BindInventoryFood() end
    -- end))
    -- table.insert(BRVS_InvFoodConns, data.ChildRemoved:Connect(function(child)
    --     if child.Name == "Asset" then BRVS_RebuildFoodText(nil) end
    -- end))
end

-- Paragraph element for Eggs
local BRVS_InvEggPara = BRVS_InvTab:CreateParagraph({
    Title = "Eggs",
    Content = "loading..."
})

-- Connections we manage for live updates
local BRVS_InvEggConns, BRVS_InvEggPerItemConns = {}, {}

local function BRVS_ClearInvEggConns()
    for _, c in ipairs(BRVS_InvEggConns) do pcall(function() c:Disconnect() end) end
    BRVS_InvEggConns = {}
    for inst, list in pairs(BRVS_InvEggPerItemConns) do
        for _, c in ipairs(list) do pcall(function() c:Disconnect() end) end
        BRVS_InvEggPerItemConns[inst] = nil
    end
end

local function BRVS_HumanEggName(tVal)
    local base = tostring(tVal or "Unknown")
    base = base:gsub("Egg$", "")
    if #base > 0 then
        base = base:sub(1,1):upper() .. base:sub(2):lower()
    end
    return base .. " egg"
end

local function BRVS_RebuildEggInventoryText(eggsFolder)
    if not BRVS_InvEggPara then return end
    if not eggsFolder then
        BRVS_InvEggPara:Set({ Title = "Eggs", Content = "(none)" })
        return
    end

    -- Tally by (T, M), skipping eggs with attribute D
	local counts = {}  -- key: T .. "\0" .. (M or "")
	for _, egg in ipairs(eggsFolder:GetChildren()) do
		-- Skip eggs marked with D
		if not egg:GetAttribute("D") then
			local T = egg:GetAttribute("T")
			local M = egg:GetAttribute("M")
			local key = tostring(T or "Unknown") .. "\0" .. tostring(M or "")
			counts[key] = (counts[key] or 0) + 1
		end
	end


    -- Build pretty bullet lines
    local lines = {}
    for key, n in pairs(counts) do
        local T, M = key:match("^(.-)\0(.*)$")
        local name = BRVS_HumanEggName(T)
        local line
        if M and M ~= "" then
            line = string.format("• %s | %s  ×%d", name, M, n)
        else
            line = string.format("• %s  ×%d", name, n)
        end
        table.insert(lines, line)
    end
    table.sort(lines, function(a,b) return a:lower() < b:lower() end)

    local content = ""
    if #lines == 0 then
        content = "(none)"
    else
        -- join with newlines
        for i, ln in ipairs(lines) do
            if i == 1 then
                content = ln
            else
                content = content .. "\n" .. ln
            end
        end
    end

    BRVS_InvEggPara:Set({ Title = "Eggs", Content = content })
end

local function BRVS_BindInventoryEggs()
    BRVS_ClearInvEggConns()

    local pg   = BRVS_Player:WaitForChild("PlayerGui")
    local data = pg:WaitForChild("Data")
    local eggs = data:WaitForChild("Egg") -- array of uid instances with attributes T, optional M

    BRVS_RebuildEggInventoryText(eggs)

    -- React to adds/removes
    table.insert(BRVS_InvEggConns, eggs.ChildAdded:Connect(function(child)
        local list = {}
        table.insert(list, child:GetAttributeChangedSignal("T"):Connect(function()
            BRVS_RebuildEggInventoryText(eggs)
        end))
        table.insert(list, child:GetAttributeChangedSignal("M"):Connect(function()
            BRVS_RebuildEggInventoryText(eggs)
        end))
		table.insert(list, child:GetAttributeChangedSignal("D"):Connect(function()
			BRVS_RebuildEggInventoryText(eggs)
		end))
        BRVS_InvEggPerItemConns[child] = list
        BRVS_RebuildEggInventoryText(eggs)
    end))

    table.insert(BRVS_InvEggConns, eggs.ChildRemoved:Connect(function(child)
        local list = BRVS_InvEggPerItemConns[child]
        if list then
            for _, c in ipairs(list) do pcall(function() c:Disconnect() end) end
        end
        BRVS_InvEggPerItemConns[child] = nil
        BRVS_RebuildEggInventoryText(eggs)
    end))

    -- Hook existing items for attribute changes
    for _, child in ipairs(eggs:GetChildren()) do
        local list = {}
        table.insert(list, child:GetAttributeChangedSignal("T"):Connect(function()
            BRVS_RebuildEggInventoryText(eggs)
        end))
        table.insert(list, child:GetAttributeChangedSignal("M"):Connect(function()
            BRVS_RebuildEggInventoryText(eggs)
        end))
		table.insert(list, child:GetAttributeChangedSignal("D"):Connect(function()
			BRVS_RebuildEggInventoryText(eggs)
		end))
        BRVS_InvEggPerItemConns[child] = list
    end
end

-- call once on init (after window creation)
-- BRVS_BindInventoryEggs()

-- =================== TAB: Utils ===================
local BRVS_UtilsTab = BRVS_Window:CreateTab("Utils", "sliders")

BRVS_UtilsTab:CreateSection("Ultra Low")
local BRVS_UltraLowToggle = BRVS_UtilsTab:CreateToggle({
	Name = "Ultra Low (No Lag + Low Graphics)",
	CurrentValue = false,
	Flag = "UltraLow",
	Callback = function(on)
		if on then
			BRVS_ApplyUltraLow()
		else
			BRVS_RestoreUltraLow()
		end
	end,
})

BRVS_UtilsTab:CreateSection("AFK")

local ActiveAFKMode = nil
local BRVS_AntiAfkConn = nil
local BRVS_AntiAfkThread = nil

-- stop any AFK thread/connections
local function StopAFK()
	if BRVS_AntiAfkConn then
		BRVS_AntiAfkConn:Disconnect()
		BRVS_AntiAfkConn = nil
	end
	BRVS_AntiAfkThread = nil
	ActiveAFKMode = nil
end

-- Perform jump
local function BRVS_PerformJump(times)
	local char = BRVS_Players.LocalPlayer.Character
	local hum = char and char:FindFirstChildOfClass("Humanoid")
	if hum then
		for _=1, times do
			hum.Jump = true
			task.wait(0.2)
		end
	end
end

-- Anti AFK 1 = jump
local function StartAFK_Jump()
	StopAFK()
	ActiveAFKMode = "Jump"

	-- hook Roblox idle event
	BRVS_AntiAfkConn = BRVS_Players.LocalPlayer.Idled:Connect(function()
		BRVS_PerformJump(1)
	end)

	-- periodic jumps
	BRVS_AntiAfkThread = task.spawn(function()
		while ActiveAFKMode == "Jump" do
			BRVS_PerformJump(1)
			local t = math.random(30, 60) -- random 30–60s
			local elapsed = 0
			while ActiveAFKMode == "Jump" and elapsed < t do
				task.wait(0.25)
				elapsed = elapsed + 0.25
			end
		end
	end)
end

-- Anti AFK 2 = virtual click
local VirtualInputManager = game:GetService("VirtualInputManager")
local function StartAFK_Click()
	StopAFK()
	ActiveAFKMode = "Click"

	BRVS_AntiAfkThread = task.spawn(function()
		while ActiveAFKMode == "Click" do
			pcall(function()
				VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
				VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
			end)
			local t = math.random(20, 45) -- random 20–45s
			local elapsed = 0
			while ActiveAFKMode == "Click" and elapsed < t do
				task.wait(0.25)
				elapsed = elapsed + 0.25
			end
		end
	end)
end

-- === UI Toggles (mutually exclusive) ===
BRVS_UtilsTab:CreateToggle({
	Name = "Anti AFK 1 (Jump)",
	CurrentValue = false,
	Flag = "AntiAFK1",
	Callback = function(on)
		if on then
			StartAFK_Jump()
			-- turn off other toggle
			BRVS_Rayfield.Flags["AntiAFK2"].Set(false)
		elseif ActiveAFKMode == "Jump" then
			StopAFK()
		end
	end,
})

BRVS_UtilsTab:CreateToggle({
	Name = "Anti AFK 2 (Virtual Click)",
	CurrentValue = false,
	Flag = "AntiAFK2",
	Callback = function(on)
		if on then
			StartAFK_Click()
			-- turn off other toggle
			BRVS_Rayfield.Flags["AntiAFK1"].Set(false)
		elseif ActiveAFKMode == "Click" then
			StopAFK()
		end
	end,
})

--========================================================
-- Bind island, LIVE stock, inventory, load config
if BRVS_IslandName then
	BRVS_BindIsland(BRVS_IslandName)
else
	BRVS_Rayfield:Notify({ Title = "Egg Tools", Content = "You are not occupying Island_1..Island_6", Duration = 6, Image = "alert-triangle" })
end


-- Load saved UI state
BRVS_Rayfield:LoadConfiguration()

BRVS_BindFoodStock()
BRVS_BindInventoryFood()
BRVS_BindInventoryEggs()
-- Sync state from saved flags (prefixed)
do
	-- Dropdowns
	if BRVS_EggDD and BRVS_EggDD.CurrentOption then BRVS_SelEggNames = BRVS_EggDD.CurrentOption or {} end
	if BRVS_MutDD and BRVS_MutDD.CurrentOption then BRVS_SelMutations = BRVS_MutDD.CurrentOption or {} end
	if BRVS_FoodDD and BRVS_FoodDD.CurrentOption then BRVS_SelectedFood = BRVS_FoodDD.CurrentOption or {} end

	-- Auto Buy Eggs
	if BRVS_AutoBuyToggle and BRVS_AutoBuyToggle.CurrentValue then
		BRVS_AutoBuyEnabled = true
		BRVS_RescanAutoBuy()
	end

	-- Auto Buy Food (fixed tick)
	if BRVS_AutoBuyFoodToggle and BRVS_AutoBuyFoodToggle.CurrentValue and not BRVS_FoodBuyThread then
		BRVS_FoodBuyEnabled = true
		BRVS_FoodBuyThread = task.spawn(function()
			while BRVS_FoodBuyEnabled do
				local foods = (BRVS_SelectedFood and #BRVS_SelectedFood > 0) and BRVS_SelectedFood or {}
				local remote = BRVS_GetRemote(BRVS_FOOD_REMOTE_PATH)
				if #foods > 0 and remote and remote:IsA("RemoteEvent") then
					for _, item in ipairs(foods) do
						if not BRVS_FoodBuyEnabled then break end
						if BRVS_HasFoodStock(item) then
							remote:FireServer(item)
							task.wait(0.05)
						end
					end
				end
				task.wait(BRVS_FoodBuyInterval)
			end
		end)
	end

	-- Auto Collect Pet
	if BRVS_PetDelaySlider and BRVS_PetDelaySlider.CurrentValue then
		BRVS_PetCollectInterval = BRVS_PetDelaySlider.CurrentValue
	end
	if BRVS_PetToggle and BRVS_PetToggle.CurrentValue and not BRVS_PetCollectThread then
		BRVS_PetCollectEnabled = true
		BRVS_PetCollectThread = task.spawn(function()
			while BRVS_PetCollectEnabled do
				BRVS_ClaimMyPetsOnce()
				local t = math.max(0.1, BRVS_PetDelaySlider.CurrentValue or BRVS_PetCollectInterval or 3)
				local elapsed = 0
				while BRVS_PetCollectEnabled and elapsed < t do
					task.wait(0.1); elapsed = elapsed + 0.1
				end
			end
		end)
	end

	-- Auto Collect Big Pet
	-- if BRVS_BigPetDelaySlider and BRVS_BigPetDelaySlider.CurrentValue then
	-- 	BRVS_BigPetCollectInterval = BRVS_BigPetDelaySlider.CurrentValue
	-- end
	-- if BRVS_BigPetToggle and BRVS_BigPetToggle.CurrentValue and not BRVS_BigPetCollectThread then
	-- 	BRVS_BigPetCollectEnabled = true
	-- 	BRVS_BigPetCollectThread = task.spawn(function()
	-- 		while BRVS_BigPetCollectEnabled do
	-- 			local t = math.max(0.1, BRVS_BigPetDelaySlider.CurrentValue or BRVS_BigPetCollectInterval or 5)
	-- 			local elapsed = 0
	-- 			while BRVS_BigPetCollectEnabled and elapsed < t do
	-- 				task.wait(0.1); elapsed = elapsed + 0.1
	-- 			end
	-- 		end
	-- 	end)
	-- end

	-- Ultra Low restore
	if BRVS_UltraLowToggle and BRVS_UltraLowToggle.CurrentValue then
		BRVS_ApplyUltraLow()
	end

	-- Anti AFK restore
	if BRVS_Rayfield.Flags["AntiAFK1"] and BRVS_Rayfield.Flags["AntiAFK1"].CurrentValue then
		-- Restore Jump mode
		StartAFK_Jump()
		BRVS_Rayfield.Flags["AntiAFK2"].Set(false)

	elseif BRVS_Rayfield.Flags["AntiAFK2"] and BRVS_Rayfield.Flags["AntiAFK2"].CurrentValue then
		-- Restore Click mode
		StartAFK_Click()
		BRVS_Rayfield.Flags["AntiAFK1"].Set(false)
	end

	-- Update label if needed
	if BRVS_IslandLabel and BRVS_IslandName then BRVS_IslandLabel:Set("Island: "..BRVS_IslandName) end
end
